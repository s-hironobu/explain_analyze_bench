diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 8345bc0264b..caae15f8a67 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -1103,7 +1103,7 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 		char	   *conname = NULL;
 
 		/* Must clean up instrumentation state */
-		InstrEndLoop(instr);
+		InstrEndLoopResultRelInfo(rInfo, instr);
 
 		/*
 		 * We ignore triggers that were never invoked; they likely aren't
@@ -1134,10 +1134,10 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 			if (show_relname)
 				appendStringInfo(es->str, " on %s", relname);
 			if (es->timing)
-				appendStringInfo(es->str, ": time=%.3f calls=%.0f\n",
+				appendStringInfo(es->str, ": time=%.3f calls=%lld\n",
 								 1000.0 * instr->total, instr->ntuples);
 			else
-				appendStringInfo(es->str, ": calls=%.0f\n", instr->ntuples);
+				appendStringInfo(es->str, ": calls=%lld\n", instr->ntuples);
 		}
 		else
 		{
@@ -1148,7 +1148,7 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 			if (es->timing)
 				ExplainPropertyFloat("Time", "ms", 1000.0 * instr->total, 3,
 									 es);
-			ExplainPropertyFloat("Calls", NULL, instr->ntuples, 0, es);
+			ExplainPropertyInteger("Calls", NULL, instr->ntuples, es);
 		}
 
 		if (conname)
@@ -1824,15 +1824,21 @@ ExplainNode(PlanState *planstate, List *ancestors,
 	 * auto_explain has to contend with.
 	 */
 	if (planstate->instrument)
-		InstrEndLoop(planstate->instrument);
+		InstrEndLoop(planstate);
 
 	if (es->analyze &&
 		planstate->instrument && planstate->instrument->nloops > 0)
 	{
-		double		nloops = planstate->instrument->nloops;
-		double		startup_ms = 1000.0 * planstate->instrument->startup / nloops;
-		double		total_ms = 1000.0 * planstate->instrument->total / nloops;
-		double		rows = planstate->instrument->ntuples / nloops;
+		double		startup_ms;
+		double		total_ms;
+		uint64_t 	nloops = planstate->instrument->nloops;
+		double		rows = planstate->instrument->ntuples / (double) nloops;
+
+		if (es->timing)
+		{
+			startup_ms = 1000.0 * planstate->instrument->startup / (double) nloops;
+			total_ms = 1000.0 * planstate->instrument->total / (double) nloops;
+		}
 
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 		{
@@ -1841,7 +1847,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 			if (es->timing)
 				appendStringInfo(es->str, "time=%.3f..%.3f ", startup_ms, total_ms);
 
-			appendStringInfo(es->str, "rows=%.2f loops=%.0f)", rows, nloops);
+			appendStringInfo(es->str, "rows=%.2f loops=%lld)", rows, nloops);
 		}
 		else
 		{
@@ -1853,7 +1859,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 									 3, es);
 			}
 			ExplainPropertyFloat("Actual Rows", NULL, rows, 2, es);
-			ExplainPropertyFloat("Actual Loops", NULL, nloops, 0, es);
+			ExplainPropertyInteger("Actual Loops", NULL, nloops, es);
 		}
 	}
 	else if (es->analyze)
@@ -1868,7 +1874,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 				ExplainPropertyFloat("Actual Total Time", "ms", 0.0, 3, es);
 			}
 			ExplainPropertyFloat("Actual Rows", NULL, 0.0, 0, es);
-			ExplainPropertyFloat("Actual Loops", NULL, 0.0, 0, es);
+			ExplainPropertyInteger("Actual Loops", NULL, 0, es);
 		}
 	}
 
@@ -1889,16 +1895,20 @@ ExplainNode(PlanState *planstate, List *ancestors,
 		for (int n = 0; n < w->num_workers; n++)
 		{
 			Instrumentation *instrument = &w->instrument[n];
-			double		nloops = instrument->nloops;
+			uint64_t 	nloops = instrument->nloops;
 			double		startup_ms;
 			double		total_ms;
 			double		rows;
 
 			if (nloops <= 0)
 				continue;
-			startup_ms = 1000.0 * instrument->startup / nloops;
-			total_ms = 1000.0 * instrument->total / nloops;
-			rows = instrument->ntuples / nloops;
+
+			if (es->timing)
+			{
+				startup_ms = 1000.0 * instrument->startup / (double) nloops;
+				total_ms = 1000.0 * instrument->total / (double) nloops;
+			}
+			rows = instrument->ntuples / (double) nloops;
 
 			ExplainOpenWorker(n, es);
 
@@ -1909,7 +1919,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 				if (es->timing)
 					appendStringInfo(es->str, "time=%.3f..%.3f ", startup_ms, total_ms);
 
-				appendStringInfo(es->str, "rows=%.2f loops=%.0f\n", rows, nloops);
+				appendStringInfo(es->str, "rows=%.2f loops=%lld\n", rows, nloops);
 			}
 			else
 			{
@@ -1922,7 +1932,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 				}
 
 				ExplainPropertyFloat("Actual Rows", NULL, rows, 2, es);
-				ExplainPropertyFloat("Actual Loops", NULL, nloops, 0, es);
+				ExplainPropertyInteger("Actual Loops", NULL, nloops, es);
 			}
 
 			ExplainCloseWorker(n, es);
@@ -1980,8 +1990,8 @@ ExplainNode(PlanState *planstate, List *ancestors,
 				show_instrumentation_count("Rows Removed by Filter", 1,
 										   planstate, es);
 			if (es->analyze)
-				ExplainPropertyFloat("Heap Fetches", NULL,
-									 planstate->instrument->ntuples2, 0, es);
+				ExplainPropertyInteger("Heap Fetches", NULL,
+									   planstate->instrument->ntuples2, es);
 			show_indexsearches_info(planstate, es);
 			break;
 		case T_BitmapIndexScan:
@@ -2295,7 +2305,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 		for (int n = 0; n < w->num_workers; n++)
 		{
 			Instrumentation *instrument = &w->instrument[n];
-			double		nloops = instrument->nloops;
+			uint64_t 	nloops = instrument->nloops;
 
 			if (nloops <= 0)
 				continue;
@@ -3985,7 +3995,7 @@ show_instrumentation_count(const char *qlabel, int which,
 						   PlanState *planstate, ExplainState *es)
 {
 	double		nfiltered;
-	double		nloops;
+	uint64_t 	nloops;
 
 	if (!es->analyze || !planstate->instrument)
 		return;
@@ -4000,7 +4010,7 @@ show_instrumentation_count(const char *qlabel, int which,
 	if (nfiltered > 0 || es->format != EXPLAIN_FORMAT_TEXT)
 	{
 		if (nloops > 0)
-			ExplainPropertyFloat(qlabel, NULL, nfiltered / nloops, 0, es);
+			ExplainPropertyFloat(qlabel, NULL, nfiltered / (double) nloops, 0, es);
 		else
 			ExplainPropertyFloat(qlabel, NULL, 0.0, 0, es);
 	}
@@ -4681,21 +4691,21 @@ show_modifytable_info(ModifyTableState *mtstate, List *ancestors,
 		/* EXPLAIN ANALYZE display of actual outcome for each tuple proposed */
 		if (es->analyze && mtstate->ps.instrument)
 		{
-			double		total;
-			double		insert_path;
-			double		other_path;
+			uint64_t 	total;
+			uint64_t 	insert_path;
+			uint64_t 	other_path;
 
-			InstrEndLoop(outerPlanState(mtstate)->instrument);
+			InstrEndLoop(outerPlanState(mtstate));
 
 			/* count the number of source rows */
 			total = outerPlanState(mtstate)->instrument->ntuples;
 			other_path = mtstate->ps.instrument->ntuples2;
 			insert_path = total - other_path;
 
-			ExplainPropertyFloat("Tuples Inserted", NULL,
-								 insert_path, 0, es);
-			ExplainPropertyFloat("Conflicting Tuples", NULL,
-								 other_path, 0, es);
+			ExplainPropertyInteger("Tuples Inserted", NULL,
+								   insert_path, es);
+			ExplainPropertyInteger("Conflicting Tuples", NULL,
+								   other_path, es);
 		}
 	}
 	else if (node->operation == CMD_MERGE)
@@ -4703,13 +4713,13 @@ show_modifytable_info(ModifyTableState *mtstate, List *ancestors,
 		/* EXPLAIN ANALYZE display of tuples processed */
 		if (es->analyze && mtstate->ps.instrument)
 		{
-			double		total;
-			double		insert_path;
-			double		update_path;
-			double		delete_path;
-			double		skipped_path;
+			uint64_t 	total;
+			uint64_t 	insert_path;
+			uint64_t 	update_path;
+			uint64_t 	delete_path;
+			uint64_t 	skipped_path;
 
-			InstrEndLoop(outerPlanState(mtstate)->instrument);
+			InstrEndLoop(outerPlanState(mtstate));
 
 			/* count the number of source rows */
 			total = outerPlanState(mtstate)->instrument->ntuples;
@@ -4726,22 +4736,22 @@ show_modifytable_info(ModifyTableState *mtstate, List *ancestors,
 					ExplainIndentText(es);
 					appendStringInfoString(es->str, "Tuples:");
 					if (insert_path > 0)
-						appendStringInfo(es->str, " inserted=%.0f", insert_path);
+						appendStringInfo(es->str, " inserted=%llu", insert_path);
 					if (update_path > 0)
-						appendStringInfo(es->str, " updated=%.0f", update_path);
+						appendStringInfo(es->str, " updated=%llu", update_path);
 					if (delete_path > 0)
-						appendStringInfo(es->str, " deleted=%.0f", delete_path);
+						appendStringInfo(es->str, " deleted=%llu", delete_path);
 					if (skipped_path > 0)
-						appendStringInfo(es->str, " skipped=%.0f", skipped_path);
+						appendStringInfo(es->str, " skipped=%llu", skipped_path);
 					appendStringInfoChar(es->str, '\n');
 				}
 			}
 			else
 			{
-				ExplainPropertyFloat("Tuples Inserted", NULL, insert_path, 0, es);
-				ExplainPropertyFloat("Tuples Updated", NULL, update_path, 0, es);
-				ExplainPropertyFloat("Tuples Deleted", NULL, delete_path, 0, es);
-				ExplainPropertyFloat("Tuples Skipped", NULL, skipped_path, 0, es);
+				ExplainPropertyInteger("Tuples Inserted", NULL, insert_path, es);
+				ExplainPropertyInteger("Tuples Updated", NULL, update_path, es);
+				ExplainPropertyInteger("Tuples Deleted", NULL, delete_path, es);
+				ExplainPropertyInteger("Tuples Skipped", NULL, skipped_path, es);
 			}
 		}
 	}
diff --git a/src/backend/commands/trigger.c b/src/backend/commands/trigger.c
index 7dc121f73f1..08168633060 100644
--- a/src/backend/commands/trigger.c
+++ b/src/backend/commands/trigger.c
@@ -89,6 +89,7 @@ static bool TriggerEnabled(EState *estate, ResultRelInfo *relinfo,
 						   Bitmapset *modifiedCols,
 						   TupleTableSlot *oldslot, TupleTableSlot *newslot);
 static HeapTuple ExecCallTriggerFunc(TriggerData *trigdata,
+									 ResultRelInfo *relInfo,
 									 int tgindx,
 									 FmgrInfo *finfo,
 									 Instrumentation *instr,
@@ -2306,6 +2307,7 @@ FindTriggerIncompatibleWithInheritance(TriggerDesc *trigdesc)
  */
 static HeapTuple
 ExecCallTriggerFunc(TriggerData *trigdata,
+					ResultRelInfo *relInfo,
 					int tgindx,
 					FmgrInfo *finfo,
 					Instrumentation *instr,
@@ -2390,8 +2392,8 @@ ExecCallTriggerFunc(TriggerData *trigdata,
 	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
 	 * one "tuple returned" (really the number of firings).
 	 */
-	if (instr)
-		InstrStopNode(instr + tgindx, 1);
+	if (instr && relInfo != NULL)
+		InstrStopNodeTrigger(relInfo, instr + tgindx, 1);
 
 	return (HeapTuple) DatumGetPointer(result);
 }
@@ -2435,6 +2437,7 @@ ExecBSInsertTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2496,6 +2499,7 @@ ExecBRInsertTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = oldtuple = newtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2591,6 +2595,7 @@ ExecIRInsertTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = oldtuple = newtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2655,6 +2660,7 @@ ExecBSDeleteTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2765,6 +2771,7 @@ ExecBRDeleteTriggers(EState *estate, EPQState *epqstate,
 		LocTriggerData.tg_trigtuple = trigtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2860,6 +2867,7 @@ ExecIRDeleteTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = trigtuple;
 		LocTriggerData.tg_trigger = trigger;
 		rettuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2918,6 +2926,7 @@ ExecBSUpdateTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3070,6 +3079,7 @@ ExecBRUpdateTriggers(EState *estate, EPQState *epqstate,
 		LocTriggerData.tg_newslot = newslot;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3224,6 +3234,7 @@ ExecIRUpdateTriggers(EState *estate, ResultRelInfo *relinfo,
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3282,6 +3293,7 @@ ExecBSTruncateTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -4543,6 +4555,7 @@ AfterTriggerExecute(EState *estate,
 	 * (Don't let ExecCallTriggerFunc measure EXPLAIN time.)
 	 */
 	rettuple = ExecCallTriggerFunc(&LocTriggerData,
+								   NULL,
 								   tgindx,
 								   finfo,
 								   NULL,
@@ -4577,8 +4590,8 @@ AfterTriggerExecute(EState *estate,
 	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
 	 * one "tuple returned" (really the number of firings).
 	 */
-	if (instr)
-		InstrStopNode(instr + tgindx, 1);
+	if (instr && relInfo != NULL)
+		InstrStopNodeTrigger(relInfo, instr + tgindx, 1);
 }
 
 
diff --git a/src/backend/executor/execAmi.c b/src/backend/executor/execAmi.c
index 1d0e8ad57b4..6200d8e995b 100644
--- a/src/backend/executor/execAmi.c
+++ b/src/backend/executor/execAmi.c
@@ -78,7 +78,7 @@ ExecReScan(PlanState *node)
 {
 	/* If collecting timing stats, update them */
 	if (node->instrument)
-		InstrEndLoop(node->instrument);
+		InstrEndLoop(node);
 
 	/*
 	 * If we have changed parameters, propagate that info.
diff --git a/src/backend/executor/execAsync.c b/src/backend/executor/execAsync.c
index 5d3cabe73e3..1912e130275 100644
--- a/src/backend/executor/execAsync.c
+++ b/src/backend/executor/execAsync.c
@@ -47,8 +47,8 @@ ExecAsyncRequest(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument,
-					  TupIsNull(areq->result) ? 0.0 : 1.0);
+		InstrStopNode(areq->requestee,
+					  TupIsNull(areq->result) ? 0 : 1);
 }
 
 /*
@@ -78,7 +78,7 @@ ExecAsyncConfigureWait(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument, 0.0);
+		InstrStopNode(areq->requestee, 0);
 }
 
 /*
@@ -106,8 +106,8 @@ ExecAsyncNotify(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument,
-					  TupIsNull(areq->result) ? 0.0 : 1.0);
+		InstrStopNode(areq->requestee,
+					  TupIsNull(areq->result) ? 0 : 1);
 }
 
 /*
diff --git a/src/backend/executor/execMain.c b/src/backend/executor/execMain.c
index 0391798dd2c..05a3d22e231 100644
--- a/src/backend/executor/execMain.c
+++ b/src/backend/executor/execMain.c
@@ -246,7 +246,11 @@ standard_ExecutorStart(QueryDesc *queryDesc, int eflags)
 	estate->es_snapshot = RegisterSnapshot(queryDesc->snapshot);
 	estate->es_crosscheck_snapshot = RegisterSnapshot(queryDesc->crosscheck_snapshot);
 	estate->es_top_eflags = eflags;
+#ifdef ALWAYS_INSTR
+	estate->es_instrument = true;
+#else
 	estate->es_instrument = queryDesc->instrument_options;
+#endif
 	estate->es_jit_flags = queryDesc->plannedstmt->jitFlags;
 
 	/*
@@ -384,7 +388,7 @@ standard_ExecutorRun(QueryDesc *queryDesc,
 		dest->rShutdown(dest);
 
 	if (queryDesc->totaltime)
-		InstrStopNode(queryDesc->totaltime, estate->es_processed);
+		InstrStopQueryDesc(queryDesc->totaltime, estate->es_processed);
 
 	MemoryContextSwitchTo(oldcontext);
 }
@@ -444,7 +448,7 @@ standard_ExecutorFinish(QueryDesc *queryDesc)
 		AfterTriggerEndQuery(estate);
 
 	if (queryDesc->totaltime)
-		InstrStopNode(queryDesc->totaltime, 0);
+		InstrStopQueryDesc(queryDesc->totaltime, 0);
 
 	MemoryContextSwitchTo(oldcontext);
 
diff --git a/src/backend/executor/execParallel.c b/src/backend/executor/execParallel.c
index f098a5557cf..c7af573a646 100644
--- a/src/backend/executor/execParallel.c
+++ b/src/backend/executor/execParallel.c
@@ -139,6 +139,71 @@ static bool ExecParallelRetrieveInstrumentation(PlanState *planstate,
 /* Helper function that runs in the parallel worker. */
 static DestReceiver *ExecParallelGetReceiver(dsm_segment *seg, shm_toc *toc);
 
+/* aggregate instrumentation information */
+static void
+InstrAggNode(Instrumentation *dst, Instrumentation *add)
+{
+	if (!dst->running && add->running)
+	{
+		dst->running = true;
+		dst->firsttuple = add->firsttuple;
+	}
+	else if (dst->running && add->running && dst->firsttuple > add->firsttuple)
+		dst->firsttuple = add->firsttuple;
+
+	INSTR_TIME_ADD(dst->counter, add->counter);
+
+	dst->tuplecount += add->tuplecount;
+	dst->startup += add->startup;
+	dst->total += add->total;
+	dst->ntuples += add->ntuples;
+	dst->ntuples2 += add->ntuples2;
+	dst->nloops += add->nloops;
+	dst->nfiltered1 += add->nfiltered1;
+	dst->nfiltered2 += add->nfiltered2;
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (dst->need_bufusage)
+		BufferUsageAdd(&dst->bufusage, &add->bufusage);
+
+	if (dst->need_walusage)
+		WalUsageAdd(&dst->walusage, &add->walusage);
+}
+
+static void
+InstrAggNodePlanState(PlanState *node_dst, Instrumentation *add)
+{
+	Instrumentation *dst = node_dst->instrument;
+
+	if (!dst->running && add->running)
+	{
+		dst->running = true;
+		set_running_true(node_dst);
+		dst->firsttuple = add->firsttuple;
+	}
+	else if (dst->running && add->running && dst->firsttuple > add->firsttuple)
+		dst->firsttuple = add->firsttuple;
+
+	INSTR_TIME_ADD(dst->counter, add->counter);
+
+	dst->tuplecount += add->tuplecount;
+	add_tuplecount(node_dst, add->tuplecount);
+	dst->startup += add->startup;
+	dst->total += add->total;
+	dst->ntuples += add->ntuples;
+	dst->ntuples2 += add->ntuples2;
+	dst->nloops += add->nloops;
+	dst->nfiltered1 += add->nfiltered1;
+	dst->nfiltered2 += add->nfiltered2;
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (dst->need_bufusage)
+		BufferUsageAdd(&dst->bufusage, &add->bufusage);
+
+	if (dst->need_walusage)
+		WalUsageAdd(&dst->walusage, &add->walusage);
+}
+
 /*
  * Create a serialized representation of the plan to be sent to each worker.
  */
@@ -1054,7 +1119,7 @@ ExecParallelRetrieveInstrumentation(PlanState *planstate,
 	instrument = GetInstrumentationArray(instrumentation);
 	instrument += i * instrumentation->num_workers;
 	for (n = 0; n < instrumentation->num_workers; ++n)
-		InstrAggNode(planstate->instrument, &instrument[n]);
+		InstrAggNodePlanState(planstate, &instrument[n]);
 
 	/*
 	 * Also store the per-worker detail.
@@ -1298,7 +1363,7 @@ ExecParallelReportInstrumentation(PlanState *planstate,
 	int			plan_node_id = planstate->plan->plan_node_id;
 	Instrumentation *instrument;
 
-	InstrEndLoop(planstate->instrument);
+	InstrEndLoop(planstate);
 
 	/*
 	 * If we shuffled the plan_node_id values in ps_instrument into sorted
@@ -1320,6 +1385,14 @@ ExecParallelReportInstrumentation(PlanState *planstate,
 	instrument += i * instrumentation->num_workers;
 	Assert(IsParallelWorker());
 	Assert(ParallelWorkerNumber < instrumentation->num_workers);
+
+	/*
+	 * To aggregate the data, we temporarily restore the tuplecount and running
+	 * fields to the Instrument structure.
+	 */
+	planstate->instrument->tuplecount = get_tuplecount(planstate);
+	planstate->instrument->running = is_running_true(planstate) ? true : false;
+
 	InstrAggNode(&instrument[ParallelWorkerNumber], planstate->instrument);
 
 	return planstate_tree_walker(planstate, ExecParallelReportInstrumentation,
diff --git a/src/backend/executor/execProcnode.c b/src/backend/executor/execProcnode.c
index f5f9cfbeead..c2c5a473685 100644
--- a/src/backend/executor/execProcnode.c
+++ b/src/backend/executor/execProcnode.c
@@ -121,6 +121,9 @@
 
 static TupleTableSlot *ExecProcNodeFirst(PlanState *node);
 static TupleTableSlot *ExecProcNodeInstr(PlanState *node);
+#ifndef DEV3
+static TupleTableSlot *ExecProcNodeInstrLite(PlanState *node);
+#endif
 static bool ExecShutdownNode_walker(PlanState *node, void *context);
 
 
@@ -461,8 +464,44 @@ ExecProcNodeFirst(PlanState *node)
 	 * does instrumentation.  Otherwise we can dispense with all wrappers and
 	 * have ExecProcNode() directly call the relevant function from now on.
 	 */
+	set_fast_path_instr_false(node);
+
 	if (node->instrument)
-		node->ExecProcNode = ExecProcNodeInstr;
+	{
+#ifdef DEV3
+		/*--
+		 * Use node->ExecProcNodeReal, which is modified to call PostExecProcNodeInstr
+		 * before returning the result, to avoid calling InstrStartNode() and
+		 * InstrStopNode() when the following conditions are not required:
+		 * - need_timer
+		 * - need_bufusage
+		 * - need_walusage
+		 */
+		if (node->instrument->need_timer || node->instrument->need_bufusage
+			|| node->instrument->need_walusage)
+		{
+			node->ExecProcNode = ExecProcNodeInstr;
+		}
+		else
+		{
+			set_fast_path_instr_true(node);
+			node->ExecProcNode = node->ExecProcNodeReal;
+		}
+#else
+		/*--
+		 * Use ExecProcNodeInstrLite() to avoid calling InstrStartNode()
+		 * and InstrStopNode() when the following conditions are not required:
+		 * - need_timer
+		 * - need_bufusage
+		 * - need_walusage
+		 */
+		if (node->instrument->need_timer || node->instrument->need_bufusage
+			|| node->instrument->need_walusage)
+			node->ExecProcNode = ExecProcNodeInstr;
+		else
+			node->ExecProcNode = ExecProcNodeInstrLite;
+#endif
+	}
 	else
 		node->ExecProcNode = node->ExecProcNodeReal;
 
@@ -484,10 +523,39 @@ ExecProcNodeInstr(PlanState *node)
 
 	result = node->ExecProcNodeReal(node);
 
-	InstrStopNode(node->instrument, TupIsNull(result) ? 0.0 : 1.0);
+	InstrStopNode(node, TupIsNull(result) ? 0 : 1);
+
+	return result;
+}
+
+
+#ifndef DEV3
+/*
+ * A simplified version of ExecProcNodeInstr. When the following conditions
+ * are not required, this function avoids calling InstrStartNode and InstrStopNode.
+ * Instead, it performs only two minimal checks:
+ * - need_timer
+ * - need_bufusage
+ * - need_walusage
+ */
+static TupleTableSlot *
+ExecProcNodeInstrLite(PlanState *node)
+{
+	TupleTableSlot *result;
+
+	result = node->ExecProcNodeReal(node);
+
+	/* count the returned tuples */
+	if (!TupIsNull(result))
+		node->instrument->tuplecount += 1.0;
+
+	/* Is this the first tuple of this cycle? */
+	if (!node->instrument->hot.running)
+		node->instrument->hot.running = true;
 
 	return result;
 }
+#endif
 
 
 /* ----------------------------------------------------------------
@@ -792,7 +860,7 @@ ExecShutdownNode_walker(PlanState *node, void *context)
 	 * has never been executed, so as to avoid incorrectly making it appear
 	 * that it has.
 	 */
-	if (node->instrument && node->instrument->running)
+	if (node->instrument && is_running_true(node))
 		InstrStartNode(node->instrument);
 
 	planstate_tree_walker(node, ExecShutdownNode_walker, context);
@@ -822,8 +890,8 @@ ExecShutdownNode_walker(PlanState *node, void *context)
 	}
 
 	/* Stop the node if we started it above, reporting 0 tuples. */
-	if (node->instrument && node->instrument->running)
-		InstrStopNode(node->instrument, 0);
+	if (node->instrument && is_running_true(node))
+		InstrStopNode(node, 0);
 
 	return false;
 }
diff --git a/src/backend/executor/instrument.c b/src/backend/executor/instrument.c
index 56e635f4700..52a13111747 100644
--- a/src/backend/executor/instrument.c
+++ b/src/backend/executor/instrument.c
@@ -22,8 +22,8 @@ static BufferUsage save_pgBufferUsage;
 WalUsage	pgWalUsage;
 static WalUsage save_pgWalUsage;
 
-static void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);
-static void WalUsageAdd(WalUsage *dst, WalUsage *add);
+/*static void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);*/
+/*static void WalUsageAdd(WalUsage *dst, WalUsage *add);*/
 
 
 /* Allocate new instrumentation structure(s) */
@@ -36,9 +36,15 @@ InstrAlloc(int n, int instrument_options, bool async_mode)
 	instr = palloc0(n * sizeof(Instrumentation));
 	if (instrument_options & (INSTRUMENT_BUFFERS | INSTRUMENT_TIMER | INSTRUMENT_WAL))
 	{
+#ifdef ALWAYS_INSTR
+		bool		need_buffers = false;
+		bool		need_wal = false;
+		bool		need_timer = false;
+#else
 		bool		need_buffers = (instrument_options & INSTRUMENT_BUFFERS) != 0;
 		bool		need_wal = (instrument_options & INSTRUMENT_WAL) != 0;
 		bool		need_timer = (instrument_options & INSTRUMENT_TIMER) != 0;
+#endif
 		int			i;
 
 		for (i = 0; i < n; i++)
@@ -58,142 +64,17 @@ void
 InstrInit(Instrumentation *instr, int instrument_options)
 {
 	memset(instr, 0, sizeof(Instrumentation));
+#ifdef ALWAYS_INSTR
+	instr->need_bufusage = false;
+	instr->need_walusage = false;
+	instr->need_timer = false;
+#else
 	instr->need_bufusage = (instrument_options & INSTRUMENT_BUFFERS) != 0;
 	instr->need_walusage = (instrument_options & INSTRUMENT_WAL) != 0;
 	instr->need_timer = (instrument_options & INSTRUMENT_TIMER) != 0;
+#endif
 }
 
-/* Entry to a plan node */
-void
-InstrStartNode(Instrumentation *instr)
-{
-	if (instr->need_timer &&
-		!INSTR_TIME_SET_CURRENT_LAZY(instr->starttime))
-		elog(ERROR, "InstrStartNode called twice in a row");
-
-	/* save buffer usage totals at node entry, if needed */
-	if (instr->need_bufusage)
-		instr->bufusage_start = pgBufferUsage;
-
-	if (instr->need_walusage)
-		instr->walusage_start = pgWalUsage;
-}
-
-/* Exit from a plan node */
-void
-InstrStopNode(Instrumentation *instr, double nTuples)
-{
-	double		save_tuplecount = instr->tuplecount;
-	instr_time	endtime;
-
-	/* count the returned tuples */
-	instr->tuplecount += nTuples;
-
-	/* let's update the time only if the timer was requested */
-	if (instr->need_timer)
-	{
-		if (INSTR_TIME_IS_ZERO(instr->starttime))
-			elog(ERROR, "InstrStopNode called without start");
-
-		INSTR_TIME_SET_CURRENT(endtime);
-		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
-
-		INSTR_TIME_SET_ZERO(instr->starttime);
-	}
-
-	/* Add delta of buffer usage since entry to node's totals */
-	if (instr->need_bufusage)
-		BufferUsageAccumDiff(&instr->bufusage,
-							 &pgBufferUsage, &instr->bufusage_start);
-
-	if (instr->need_walusage)
-		WalUsageAccumDiff(&instr->walusage,
-						  &pgWalUsage, &instr->walusage_start);
-
-	/* Is this the first tuple of this cycle? */
-	if (!instr->running)
-	{
-		instr->running = true;
-		instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
-	}
-	else
-	{
-		/*
-		 * In async mode, if the plan node hadn't emitted any tuples before,
-		 * this might be the first tuple
-		 */
-		if (instr->async_mode && save_tuplecount < 1.0)
-			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
-	}
-}
-
-/* Update tuple count */
-void
-InstrUpdateTupleCount(Instrumentation *instr, double nTuples)
-{
-	/* count the returned tuples */
-	instr->tuplecount += nTuples;
-}
-
-/* Finish a run cycle for a plan node */
-void
-InstrEndLoop(Instrumentation *instr)
-{
-	double		totaltime;
-
-	/* Skip if nothing has happened, or already shut down */
-	if (!instr->running)
-		return;
-
-	if (!INSTR_TIME_IS_ZERO(instr->starttime))
-		elog(ERROR, "InstrEndLoop called on running node");
-
-	/* Accumulate per-cycle statistics into totals */
-	totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
-
-	instr->startup += instr->firsttuple;
-	instr->total += totaltime;
-	instr->ntuples += instr->tuplecount;
-	instr->nloops += 1;
-
-	/* Reset for next cycle (if any) */
-	instr->running = false;
-	INSTR_TIME_SET_ZERO(instr->starttime);
-	INSTR_TIME_SET_ZERO(instr->counter);
-	instr->firsttuple = 0;
-	instr->tuplecount = 0;
-}
-
-/* aggregate instrumentation information */
-void
-InstrAggNode(Instrumentation *dst, Instrumentation *add)
-{
-	if (!dst->running && add->running)
-	{
-		dst->running = true;
-		dst->firsttuple = add->firsttuple;
-	}
-	else if (dst->running && add->running && dst->firsttuple > add->firsttuple)
-		dst->firsttuple = add->firsttuple;
-
-	INSTR_TIME_ADD(dst->counter, add->counter);
-
-	dst->tuplecount += add->tuplecount;
-	dst->startup += add->startup;
-	dst->total += add->total;
-	dst->ntuples += add->ntuples;
-	dst->ntuples2 += add->ntuples2;
-	dst->nloops += add->nloops;
-	dst->nfiltered1 += add->nfiltered1;
-	dst->nfiltered2 += add->nfiltered2;
-
-	/* Add delta of buffer usage since entry to node's totals */
-	if (dst->need_bufusage)
-		BufferUsageAdd(&dst->bufusage, &add->bufusage);
-
-	if (dst->need_walusage)
-		WalUsageAdd(&dst->walusage, &add->walusage);
-}
 
 /* note current values during parallel executor startup */
 void
@@ -222,7 +103,7 @@ InstrAccumParallelQuery(BufferUsage *bufusage, WalUsage *walusage)
 }
 
 /* dst += add */
-static void
+void
 BufferUsageAdd(BufferUsage *dst, const BufferUsage *add)
 {
 	dst->shared_blks_hit += add->shared_blks_hit;
@@ -274,7 +155,7 @@ BufferUsageAccumDiff(BufferUsage *dst,
 }
 
 /* helper functions for WAL usage accumulation */
-static void
+void
 WalUsageAdd(WalUsage *dst, WalUsage *add)
 {
 	dst->wal_bytes += add->wal_bytes;
diff --git a/src/backend/executor/nodeAgg.c b/src/backend/executor/nodeAgg.c
index 377e016d732..4bd3e20a5e6 100644
--- a/src/backend/executor/nodeAgg.c
+++ b/src/backend/executor/nodeAgg.c
@@ -2267,10 +2267,18 @@ ExecAgg(PlanState *pstate)
 		}
 
 		if (!TupIsNull(result))
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return result;
+#endif
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /*
diff --git a/src/backend/executor/nodeAppend.c b/src/backend/executor/nodeAppend.c
index a11b36c7176..ec78532b76c 100644
--- a/src/backend/executor/nodeAppend.c
+++ b/src/backend/executor/nodeAppend.c
@@ -316,7 +316,14 @@ ExecAppend(PlanState *pstate)
 
 		/* Nothing to do if there are no subplans */
 		if (node->as_nplans == 0)
+		{
+#ifdef DEV3
+			result = ExecClearTuple(node->ps.ps_ResultTupleSlot);
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return ExecClearTuple(node->ps.ps_ResultTupleSlot);
+#endif
+		}
 
 		/* If there are any async subplans, begin executing them. */
 		if (node->as_nasyncplans > 0)
@@ -327,7 +334,14 @@ ExecAppend(PlanState *pstate)
 		 * proceeding.
 		 */
 		if (!node->choose_next_subplan(node) && node->as_nasyncremain == 0)
+		{
+#ifdef DEV3
+			result = ExecClearTuple(node->ps.ps_ResultTupleSlot);
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return ExecClearTuple(node->ps.ps_ResultTupleSlot);
+#endif
+		}
 
 		Assert(node->as_syncdone ||
 			   (node->as_whichplan >= 0 &&
@@ -349,7 +363,11 @@ ExecAppend(PlanState *pstate)
 		if (node->as_syncdone || !bms_is_empty(node->as_needrequest))
 		{
 			if (ExecAppendAsyncGetNext(node, &result))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, result);
+#else
 				return result;
+#endif
 			Assert(!node->as_syncdone);
 			Assert(bms_is_empty(node->as_needrequest));
 		}
@@ -372,7 +390,11 @@ ExecAppend(PlanState *pstate)
 			 * NOT make use of the result slot that was set up in
 			 * ExecInitAppend; there's no need for it.
 			 */
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return result;
+#endif
 		}
 
 		/*
@@ -385,7 +407,14 @@ ExecAppend(PlanState *pstate)
 
 		/* choose new sync subplan; if no sync/async subplans, we're done */
 		if (!node->choose_next_subplan(node) && node->as_nasyncremain == 0)
+		{
+#ifdef DEV3
+			result = ExecClearTuple(node->ps.ps_ResultTupleSlot);
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return ExecClearTuple(node->ps.ps_ResultTupleSlot);
+#endif
+		}
 	}
 }
 
diff --git a/src/backend/executor/nodeBitmapAnd.c b/src/backend/executor/nodeBitmapAnd.c
index 939907b6fcd..682bc00207a 100644
--- a/src/backend/executor/nodeBitmapAnd.c
+++ b/src/backend/executor/nodeBitmapAnd.c
@@ -42,7 +42,11 @@ static TupleTableSlot *
 ExecBitmapAnd(PlanState *pstate)
 {
 	elog(ERROR, "BitmapAnd node does not support ExecProcNode call convention");
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
@@ -161,7 +165,7 @@ MultiExecBitmapAnd(BitmapAndState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, 0 /* XXX */ );
+		InstrStopNode(&node->ps, 0 /* XXX */ );
 
 	return (Node *) result;
 }
diff --git a/src/backend/executor/nodeBitmapHeapscan.c b/src/backend/executor/nodeBitmapHeapscan.c
index bf24f3d7fe0..db09cbadab5 100644
--- a/src/backend/executor/nodeBitmapHeapscan.c
+++ b/src/backend/executor/nodeBitmapHeapscan.c
@@ -211,11 +211,22 @@ BitmapHeapRecheck(BitmapHeapScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecBitmapHeapScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	BitmapHeapScanState *node = castNode(BitmapHeapScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) BitmapHeapNext,
+					  (ExecScanRecheckMtd) BitmapHeapRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) BitmapHeapNext,
 					(ExecScanRecheckMtd) BitmapHeapRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeBitmapIndexscan.c b/src/backend/executor/nodeBitmapIndexscan.c
index abbb033881a..f4ad83ea347 100644
--- a/src/backend/executor/nodeBitmapIndexscan.c
+++ b/src/backend/executor/nodeBitmapIndexscan.c
@@ -38,7 +38,11 @@ static TupleTableSlot *
 ExecBitmapIndexScan(PlanState *pstate)
 {
 	elog(ERROR, "BitmapIndexScan node does not support ExecProcNode call convention");
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
@@ -115,7 +119,7 @@ MultiExecBitmapIndexScan(BitmapIndexScanState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ss.ps.instrument)
-		InstrStopNode(node->ss.ps.instrument, nTuples);
+		InstrStopNode(&node->ss.ps, nTuples);
 
 	return (Node *) tbm;
 }
diff --git a/src/backend/executor/nodeBitmapOr.c b/src/backend/executor/nodeBitmapOr.c
index 231760ec93d..714393c112c 100644
--- a/src/backend/executor/nodeBitmapOr.c
+++ b/src/backend/executor/nodeBitmapOr.c
@@ -43,7 +43,11 @@ static TupleTableSlot *
 ExecBitmapOr(PlanState *pstate)
 {
 	elog(ERROR, "BitmapOr node does not support ExecProcNode call convention");
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
@@ -179,7 +183,7 @@ MultiExecBitmapOr(BitmapOrState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, 0 /* XXX */ );
+		InstrStopNode(&node->ps, 0 /* XXX */ );
 
 	return (Node *) result;
 }
diff --git a/src/backend/executor/nodeCtescan.c b/src/backend/executor/nodeCtescan.c
index e1675f66b43..84ca39c446b 100644
--- a/src/backend/executor/nodeCtescan.c
+++ b/src/backend/executor/nodeCtescan.c
@@ -159,11 +159,22 @@ CteScanRecheck(CteScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecCteScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	CteScanState *node = castNode(CteScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) CteScanNext,
+					  (ExecScanRecheckMtd) CteScanRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) CteScanNext,
 					(ExecScanRecheckMtd) CteScanRecheck);
+#endif
 }
 
 
diff --git a/src/backend/executor/nodeCustom.c b/src/backend/executor/nodeCustom.c
index ac2196b64c7..8281b9d8814 100644
--- a/src/backend/executor/nodeCustom.c
+++ b/src/backend/executor/nodeCustom.c
@@ -113,12 +113,20 @@ ExecInitCustomScan(CustomScan *cscan, EState *estate, int eflags)
 static TupleTableSlot *
 ExecCustomScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	CustomScanState *node = castNode(CustomScanState, pstate);
 
 	CHECK_FOR_INTERRUPTS();
 
 	Assert(node->methods->ExecCustomScan != NULL);
+#ifdef DEV3
+	result = node->methods->ExecCustomScan(node);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return node->methods->ExecCustomScan(node);
+#endif
 }
 
 void
diff --git a/src/backend/executor/nodeForeignscan.c b/src/backend/executor/nodeForeignscan.c
index 9c56c2f3acf..73eaa7b2e8c 100644
--- a/src/backend/executor/nodeForeignscan.c
+++ b/src/backend/executor/nodeForeignscan.c
@@ -117,6 +117,9 @@ ForeignRecheck(ForeignScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecForeignScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	ForeignScanState *node = castNode(ForeignScanState, pstate);
 	ForeignScan *plan = (ForeignScan *) node->ss.ps.plan;
 	EState	   *estate = node->ss.ps.state;
@@ -126,11 +129,23 @@ ExecForeignScan(PlanState *pstate)
 	 * irrelevant for EvalPlanQual rechecking
 	 */
 	if (estate->es_epq_active != NULL && plan->operation != CMD_SELECT)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) ForeignNext,
+					  (ExecScanRecheckMtd) ForeignRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) ForeignNext,
 					(ExecScanRecheckMtd) ForeignRecheck);
+#endif
 }
 
 
diff --git a/src/backend/executor/nodeFunctionscan.c b/src/backend/executor/nodeFunctionscan.c
index 644363582d9..8e13cc7e61a 100644
--- a/src/backend/executor/nodeFunctionscan.c
+++ b/src/backend/executor/nodeFunctionscan.c
@@ -264,11 +264,22 @@ FunctionRecheck(FunctionScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecFunctionScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	FunctionScanState *node = castNode(FunctionScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) FunctionNext,
+					  (ExecScanRecheckMtd) FunctionRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) FunctionNext,
 					(ExecScanRecheckMtd) FunctionRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeGather.c b/src/backend/executor/nodeGather.c
index dc7d1830259..d630771c2d6 100644
--- a/src/backend/executor/nodeGather.c
+++ b/src/backend/executor/nodeGather.c
@@ -139,6 +139,9 @@ ExecGather(PlanState *pstate)
 	GatherState *node = castNode(GatherState, pstate);
 	TupleTableSlot *slot;
 	ExprContext *econtext;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -228,17 +231,30 @@ ExecGather(PlanState *pstate)
 	 */
 	slot = gather_getnext(node);
 	if (TupIsNull(slot))
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
 	/* If no projection is required, we're done. */
 	if (node->ps.ps_ProjInfo == NULL)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, slot);
+#else
 		return slot;
+#endif
 
 	/*
 	 * Form the result tuple using ExecProject(), and return it.
 	 */
 	econtext->ecxt_outertuple = slot;
+#ifdef DEV3
+	result = ExecProject(node->ps.ps_ProjInfo);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecProject(node->ps.ps_ProjInfo);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeGatherMerge.c b/src/backend/executor/nodeGatherMerge.c
index 15f84597067..e81b5868791 100644
--- a/src/backend/executor/nodeGatherMerge.c
+++ b/src/backend/executor/nodeGatherMerge.c
@@ -185,6 +185,9 @@ ExecGatherMerge(PlanState *pstate)
 	GatherMergeState *node = castNode(GatherMergeState, pstate);
 	TupleTableSlot *slot;
 	ExprContext *econtext;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -268,17 +271,30 @@ ExecGatherMerge(PlanState *pstate)
 	 */
 	slot = gather_merge_getnext(node);
 	if (TupIsNull(slot))
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
 	/* If no projection is required, we're done. */
 	if (node->ps.ps_ProjInfo == NULL)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, slot);
+#else
 		return slot;
+#endif
 
 	/*
 	 * Form the result tuple using ExecProject(), and return it.
 	 */
 	econtext->ecxt_outertuple = slot;
+#ifdef DEV3
+	result = ExecProject(node->ps.ps_ProjInfo);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecProject(node->ps.ps_ProjInfo);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeGroup.c b/src/backend/executor/nodeGroup.c
index 05fdd96f835..b77fbbc4b5f 100644
--- a/src/backend/executor/nodeGroup.c
+++ b/src/backend/executor/nodeGroup.c
@@ -39,6 +39,9 @@ ExecGroup(PlanState *pstate)
 	ExprContext *econtext;
 	TupleTableSlot *firsttupleslot;
 	TupleTableSlot *outerslot;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -46,7 +49,12 @@ ExecGroup(PlanState *pstate)
 	 * get state info from node
 	 */
 	if (node->grp_done)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
+
 	econtext = node->ss.ps.ps_ExprContext;
 
 	/*
@@ -70,7 +78,11 @@ ExecGroup(PlanState *pstate)
 		{
 			/* empty input, so return nothing */
 			node->grp_done = true;
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 		}
 		/* Copy tuple into firsttupleslot */
 		ExecCopySlot(firsttupleslot, outerslot);
@@ -90,7 +102,12 @@ ExecGroup(PlanState *pstate)
 			/*
 			 * Form and return a projection tuple using the first input tuple.
 			 */
+#ifdef DEV3
+			result = ExecProject(node->ss.ps.ps_ProjInfo);
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return ExecProject(node->ss.ps.ps_ProjInfo);
+#endif
 		}
 		else
 			InstrCountFiltered1(node, 1);
@@ -113,7 +130,11 @@ ExecGroup(PlanState *pstate)
 			{
 				/* no more groups, so we're done */
 				node->grp_done = true;
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 			}
 
 			/*
@@ -143,7 +164,12 @@ ExecGroup(PlanState *pstate)
 			/*
 			 * Form and return a projection tuple using the first input tuple.
 			 */
+#ifdef DEV3
+			result = ExecProject(node->ss.ps.ps_ProjInfo);
+			return PostExecProcNodeInstr(pstate, result);
+#else
 			return ExecProject(node->ss.ps.ps_ProjInfo);
+#endif
 		}
 		else
 			InstrCountFiltered1(node, 1);
diff --git a/src/backend/executor/nodeHash.c b/src/backend/executor/nodeHash.c
index 8d2201ab67f..9e2af970ed7 100644
--- a/src/backend/executor/nodeHash.c
+++ b/src/backend/executor/nodeHash.c
@@ -91,7 +91,11 @@ static TupleTableSlot *
 ExecHash(PlanState *pstate)
 {
 	elog(ERROR, "Hash node does not support ExecProcNode call convention");
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
@@ -115,7 +119,7 @@ MultiExecHash(HashState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, node->hashtable->partialTuples);
+		InstrStopNode(&node->ps, node->hashtable->partialTuples);
 
 	/*
 	 * We do not return the hash table directly because it's not a subtype of
diff --git a/src/backend/executor/nodeHashjoin.c b/src/backend/executor/nodeHashjoin.c
index 5661ad76830..6a15200b3dc 100644
--- a/src/backend/executor/nodeHashjoin.c
+++ b/src/backend/executor/nodeHashjoin.c
@@ -683,11 +683,20 @@ ExecHashJoinImpl(PlanState *pstate, bool parallel)
 static TupleTableSlot *			/* return: a tuple or NULL */
 ExecHashJoin(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
+
 	/*
 	 * On sufficiently smart compilers this should be inlined with the
 	 * parallel-aware branches removed.
 	 */
+#ifdef DEV3
+	result = ExecHashJoinImpl(pstate, false);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecHashJoinImpl(pstate, false);
+#endif
 }
 
 /* ----------------------------------------------------------------
@@ -699,11 +708,20 @@ ExecHashJoin(PlanState *pstate)
 static TupleTableSlot *			/* return: a tuple or NULL */
 ExecParallelHashJoin(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
+
 	/*
 	 * On sufficiently smart compilers this should be inlined with the
 	 * parallel-oblivious branches removed.
 	 */
+#ifdef DEV3
+	result = ExecHashJoinImpl(pstate, true);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecHashJoinImpl(pstate, true);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeIncrementalSort.c b/src/backend/executor/nodeIncrementalSort.c
index 975b0397e7a..a232cec4841 100644
--- a/src/backend/executor/nodeIncrementalSort.c
+++ b/src/backend/executor/nodeIncrementalSort.c
@@ -543,7 +543,12 @@ ExecIncrementalSort(PlanState *pstate)
 			 * check directly, but we need it for any plan where the outer
 			 * node will fail when trying to fetch too many tuples.
 			 */
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, slot);
+#else
 			return slot;
+#endif
+
 		else if (node->n_fullsort_remaining > 0)
 		{
 			/*
@@ -962,7 +967,12 @@ ExecIncrementalSort(PlanState *pstate)
 	slot = node->ss.ps.ps_ResultTupleSlot;
 	(void) tuplesort_gettupleslot(read_sortstate, ScanDirectionIsForward(dir),
 								  false, slot, NULL);
+
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, slot);
+#else
 	return slot;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeIndexonlyscan.c b/src/backend/executor/nodeIndexonlyscan.c
index f464cca9507..8e0915af79e 100644
--- a/src/backend/executor/nodeIndexonlyscan.c
+++ b/src/backend/executor/nodeIndexonlyscan.c
@@ -336,6 +336,10 @@ IndexOnlyRecheck(IndexOnlyScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecIndexOnlyScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
+
 	IndexOnlyScanState *node = castNode(IndexOnlyScanState, pstate);
 
 	/*
@@ -344,9 +348,17 @@ ExecIndexOnlyScan(PlanState *pstate)
 	if (node->ioss_NumRuntimeKeys != 0 && !node->ioss_RuntimeKeysReady)
 		ExecReScan((PlanState *) node);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) IndexOnlyNext,
+					  (ExecScanRecheckMtd) IndexOnlyRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) IndexOnlyNext,
 					(ExecScanRecheckMtd) IndexOnlyRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeIndexscan.c b/src/backend/executor/nodeIndexscan.c
index 7fcaa37fe62..3425baeb2a2 100644
--- a/src/backend/executor/nodeIndexscan.c
+++ b/src/backend/executor/nodeIndexscan.c
@@ -521,6 +521,9 @@ static TupleTableSlot *
 ExecIndexScan(PlanState *pstate)
 {
 	IndexScanState *node = castNode(IndexScanState, pstate);
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	/*
 	 * If we have runtime keys and they've not already been set up, do it now.
@@ -529,13 +532,33 @@ ExecIndexScan(PlanState *pstate)
 		ExecReScan((PlanState *) node);
 
 	if (node->iss_NumOrderByKeys > 0)
+	{
+#ifdef DEV3
+		result = ExecScan(&node->ss,
+						  (ExecScanAccessMtd) IndexNextWithReorder,
+						  (ExecScanRecheckMtd) IndexRecheck);
+
+		return PostExecProcNodeInstr(pstate, result);
+#else
 		return ExecScan(&node->ss,
 						(ExecScanAccessMtd) IndexNextWithReorder,
 						(ExecScanRecheckMtd) IndexRecheck);
+#endif
+	}
 	else
+	{
+#ifdef DEV3
+		result = ExecScan(&node->ss,
+						  (ExecScanAccessMtd) IndexNext,
+						  (ExecScanRecheckMtd) IndexRecheck);
+
+		return PostExecProcNodeInstr(pstate, result);
+#else
 		return ExecScan(&node->ss,
 						(ExecScanAccessMtd) IndexNext,
 						(ExecScanRecheckMtd) IndexRecheck);
+#endif
+	}
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeLimit.c b/src/backend/executor/nodeLimit.c
index f957da4470e..76280b4e5ea 100644
--- a/src/backend/executor/nodeLimit.c
+++ b/src/backend/executor/nodeLimit.c
@@ -76,7 +76,11 @@ ExecLimit(PlanState *pstate)
 			 * If backwards scan, just return NULL without changing state.
 			 */
 			if (!ScanDirectionIsForward(direction))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 
 			/*
 			 * Check for empty window; if so, treat like empty subplan.
@@ -84,7 +88,11 @@ ExecLimit(PlanState *pstate)
 			if (node->count <= 0 && !node->noCount)
 			{
 				node->lstate = LIMIT_EMPTY;
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 			}
 
 			/*
@@ -100,7 +108,11 @@ ExecLimit(PlanState *pstate)
 					 * any output at all.
 					 */
 					node->lstate = LIMIT_EMPTY;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/*
@@ -129,7 +141,11 @@ ExecLimit(PlanState *pstate)
 			 * The subplan is known to return no tuples (or not more than
 			 * OFFSET tuples, in general).  So we return no tuples.
 			 */
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 
 		case LIMIT_INWINDOW:
 			if (ScanDirectionIsForward(direction))
@@ -156,7 +172,11 @@ ExecLimit(PlanState *pstate)
 					if (node->limitOption == LIMIT_OPTION_COUNT)
 					{
 						node->lstate = LIMIT_WINDOWEND;
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 					}
 					else
 					{
@@ -173,7 +193,11 @@ ExecLimit(PlanState *pstate)
 					if (TupIsNull(slot))
 					{
 						node->lstate = LIMIT_SUBPLANEOF;
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 					}
 
 					/*
@@ -200,7 +224,11 @@ ExecLimit(PlanState *pstate)
 				if (node->position <= node->offset + 1)
 				{
 					node->lstate = LIMIT_WINDOWSTART;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/*
@@ -228,7 +256,11 @@ ExecLimit(PlanState *pstate)
 				if (TupIsNull(slot))
 				{
 					node->lstate = LIMIT_SUBPLANEOF;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/*
@@ -245,7 +277,11 @@ ExecLimit(PlanState *pstate)
 				else
 				{
 					node->lstate = LIMIT_WINDOWEND;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 			}
 			else
@@ -257,7 +293,11 @@ ExecLimit(PlanState *pstate)
 				if (node->position <= node->offset + 1)
 				{
 					node->lstate = LIMIT_WINDOWSTART;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/*
@@ -275,7 +315,11 @@ ExecLimit(PlanState *pstate)
 
 		case LIMIT_SUBPLANEOF:
 			if (ScanDirectionIsForward(direction))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 
 			/*
 			 * Backing up from subplan EOF, so re-fetch previous tuple; there
@@ -291,7 +335,11 @@ ExecLimit(PlanState *pstate)
 
 		case LIMIT_WINDOWEND:
 			if (ScanDirectionIsForward(direction))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 
 			/*
 			 * We already past one position to detect ties so re-fetch
@@ -320,7 +368,11 @@ ExecLimit(PlanState *pstate)
 
 		case LIMIT_WINDOWSTART:
 			if (!ScanDirectionIsForward(direction))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 
 			/*
 			 * Advancing after having backed off window start: simply
@@ -341,7 +393,11 @@ ExecLimit(PlanState *pstate)
 	/* Return the current tuple */
 	Assert(!TupIsNull(slot));
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, slot);
+#else
 	return slot;
+#endif
 }
 
 /*
diff --git a/src/backend/executor/nodeLockRows.c b/src/backend/executor/nodeLockRows.c
index a8afbf93b48..2c42756f297 100644
--- a/src/backend/executor/nodeLockRows.c
+++ b/src/backend/executor/nodeLockRows.c
@@ -62,7 +62,11 @@ lnext:
 	{
 		/* Release any resources held by EPQ mechanism before exiting */
 		EvalPlanQualEnd(&node->lr_epqstate);
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 	}
 
 	/* We don't need EvalPlanQual unless we get updated tuple version(s) */
@@ -277,7 +281,11 @@ lnext:
 	}
 
 	/* Got all locks, so return the current tuple */
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, slot);
+#else
 	return slot;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeMaterial.c b/src/backend/executor/nodeMaterial.c
index 9798bb75365..00015e3537d 100644
--- a/src/backend/executor/nodeMaterial.c
+++ b/src/backend/executor/nodeMaterial.c
@@ -45,6 +45,10 @@ ExecMaterial(PlanState *pstate)
 	Tuplestorestate *tuplestorestate;
 	bool		eof_tuplestore;
 	TupleTableSlot *slot;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
+
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -96,7 +100,11 @@ ExecMaterial(PlanState *pstate)
 			 * fetch.
 			 */
 			if (!tuplestore_advance(tuplestorestate, forward))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;	/* the tuplestore must be empty */
+#endif
 		}
 		eof_tuplestore = false;
 	}
@@ -108,7 +116,11 @@ ExecMaterial(PlanState *pstate)
 	if (!eof_tuplestore)
 	{
 		if (tuplestore_gettupleslot(tuplestorestate, forward, false, slot))
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, slot);
+#else
 			return slot;
+#endif
 		if (forward)
 			eof_tuplestore = true;
 	}
@@ -135,7 +147,11 @@ ExecMaterial(PlanState *pstate)
 		if (TupIsNull(outerslot))
 		{
 			node->eof_underlying = true;
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 		}
 
 		/*
@@ -147,13 +163,22 @@ ExecMaterial(PlanState *pstate)
 			tuplestore_puttupleslot(tuplestorestate, outerslot);
 
 		ExecCopySlot(slot, outerslot);
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, slot);
+#else
 		return slot;
+#endif
 	}
 
 	/*
 	 * Nothing left ...
 	 */
+#ifdef DEV3
+	result = ExecClearTuple(slot);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecClearTuple(slot);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeMemoize.c b/src/backend/executor/nodeMemoize.c
index 609deb12afb..04a5d7cdac1 100644
--- a/src/backend/executor/nodeMemoize.c
+++ b/src/backend/executor/nodeMemoize.c
@@ -760,12 +760,20 @@ ExecMemoize(PlanState *pstate)
 						ExecStoreMinimalTuple(entry->tuplehead->mintuple,
 											  slot, false);
 
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, slot);
+#else
 						return slot;
+#endif
 					}
 
 					/* The cache entry is void of any tuples. */
 					node->mstatus = MEMO_END_OF_SCAN;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/* Handle cache miss */
@@ -800,7 +808,11 @@ ExecMemoize(PlanState *pstate)
 						entry->complete = true;
 
 					node->mstatus = MEMO_END_OF_SCAN;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				node->entry = entry;
@@ -835,7 +847,11 @@ ExecMemoize(PlanState *pstate)
 
 				slot = node->ss.ps.ps_ResultTupleSlot;
 				ExecCopySlot(slot, outerslot);
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, slot);
+#else
 				return slot;
+#endif
 			}
 
 		case MEMO_CACHE_FETCH_NEXT_TUPLE:
@@ -851,14 +867,22 @@ ExecMemoize(PlanState *pstate)
 				if (node->last_tuple == NULL)
 				{
 					node->mstatus = MEMO_END_OF_SCAN;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				slot = node->ss.ps.ps_ResultTupleSlot;
 				ExecStoreMinimalTuple(node->last_tuple->mintuple, slot,
 									  false);
 
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, slot);
+#else
 				return slot;
+#endif
 			}
 
 		case MEMO_FILLING_CACHE:
@@ -881,7 +905,11 @@ ExecMemoize(PlanState *pstate)
 					/* No more tuples.  Mark it as complete */
 					entry->complete = true;
 					node->mstatus = MEMO_END_OF_SCAN;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/*
@@ -908,7 +936,11 @@ ExecMemoize(PlanState *pstate)
 
 				slot = node->ss.ps.ps_ResultTupleSlot;
 				ExecCopySlot(slot, outerslot);
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, slot);
+#else
 				return slot;
+#endif
 			}
 
 		case MEMO_CACHE_BYPASS_MODE:
@@ -925,12 +957,20 @@ ExecMemoize(PlanState *pstate)
 				if (TupIsNull(outerslot))
 				{
 					node->mstatus = MEMO_END_OF_SCAN;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				slot = node->ss.ps.ps_ResultTupleSlot;
 				ExecCopySlot(slot, outerslot);
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, slot);
+#else
 				return slot;
+#endif
 			}
 
 		case MEMO_END_OF_SCAN:
@@ -939,12 +979,20 @@ ExecMemoize(PlanState *pstate)
 			 * We've already returned NULL for this scan, but just in case
 			 * something calls us again by mistake.
 			 */
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 
 		default:
 			elog(ERROR, "unrecognized memoize state: %d",
 				 (int) node->mstatus);
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 	}							/* switch */
 }
 
diff --git a/src/backend/executor/nodeMergeAppend.c b/src/backend/executor/nodeMergeAppend.c
index 405e8f94285..e6ec2f868aa 100644
--- a/src/backend/executor/nodeMergeAppend.c
+++ b/src/backend/executor/nodeMergeAppend.c
@@ -224,7 +224,14 @@ ExecMergeAppend(PlanState *pstate)
 	{
 		/* Nothing to do if all subplans were pruned */
 		if (node->ms_nplans == 0)
+#ifdef DEV3
+		{
+			result = ExecClearTuple(node->ps.ps_ResultTupleSlot);
+			return PostExecProcNodeInstr(pstate, result);
+		}
+#else
 			return ExecClearTuple(node->ps.ps_ResultTupleSlot);
+#endif
 
 		/*
 		 * If we've yet to determine the valid subplans then do so now.  If
@@ -278,7 +285,11 @@ ExecMergeAppend(PlanState *pstate)
 		result = node->ms_slots[i];
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return result;
+#endif
 }
 
 /*
diff --git a/src/backend/executor/nodeMergejoin.c b/src/backend/executor/nodeMergejoin.c
index a233313128a..1ba8ad063fc 100644
--- a/src/backend/executor/nodeMergejoin.c
+++ b/src/backend/executor/nodeMergejoin.c
@@ -670,7 +670,11 @@ ExecMergeJoin(PlanState *pstate)
 
 							result = MJFillOuter(node);
 							if (result)
+#ifdef DEV3
+								return PostExecProcNodeInstr(pstate, result);
+#else
 								return result;
+#endif
 						}
 						break;
 					case MJEVAL_ENDOFJOIN:
@@ -688,7 +692,11 @@ ExecMergeJoin(PlanState *pstate)
 							break;
 						}
 						/* Otherwise we're done. */
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 				}
 				break;
 
@@ -725,7 +733,11 @@ ExecMergeJoin(PlanState *pstate)
 
 							result = MJFillInner(node);
 							if (result)
+#ifdef DEV3
+								return PostExecProcNodeInstr(pstate, result);
+#else
 								return result;
+#endif
 						}
 						break;
 					case MJEVAL_ENDOFJOIN:
@@ -745,7 +757,11 @@ ExecMergeJoin(PlanState *pstate)
 							break;
 						}
 						/* Otherwise we're done. */
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 				}
 				break;
 
@@ -822,13 +838,22 @@ ExecMergeJoin(PlanState *pstate)
 
 					if (qualResult)
 					{
+#ifdef DEV3
+						TupleTableSlot *result;
+#endif
+
 						/*
 						 * qualification succeeded.  now form the desired
 						 * projection tuple and return the slot containing it.
 						 */
 						MJ_printf("ExecMergeJoin: returning tuple\n");
 
+#ifdef DEV3
+						result = ExecProject(node->js.ps.ps_ProjInfo);
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return ExecProject(node->js.ps.ps_ProjInfo);
+#endif
 					}
 					else
 						InstrCountFiltered2(node, 1);
@@ -860,7 +885,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillInner(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/*
@@ -961,7 +990,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillOuter(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/*
@@ -997,7 +1030,11 @@ ExecMergeJoin(PlanState *pstate)
 							break;
 						}
 						/* Otherwise we're done. */
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 				}
 				break;
 
@@ -1138,7 +1175,11 @@ ExecMergeJoin(PlanState *pstate)
 								break;
 							}
 							/* Otherwise we're done. */
+#ifdef DEV3
+							return PostExecProcNodeInstr(pstate, NULL);
+#else
 							return NULL;
+#endif
 					}
 				}
 				else			/* compareResult < 0 should not happen */
@@ -1223,7 +1264,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillOuter(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/*
@@ -1259,7 +1304,11 @@ ExecMergeJoin(PlanState *pstate)
 							break;
 						}
 						/* Otherwise we're done. */
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 				}
 				break;
 
@@ -1285,7 +1334,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillInner(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/* Mark before advancing, if wanted */
@@ -1329,7 +1382,11 @@ ExecMergeJoin(PlanState *pstate)
 							break;
 						}
 						/* Otherwise we're done. */
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, NULL);
+#else
 						return NULL;
+#endif
 				}
 				break;
 
@@ -1355,7 +1412,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillInner(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/* Mark before advancing, if wanted */
@@ -1373,7 +1434,11 @@ ExecMergeJoin(PlanState *pstate)
 				if (TupIsNull(innerTupleSlot))
 				{
 					MJ_printf("ExecMergeJoin: end of inner subplan\n");
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/* Else remain in ENDOUTER state and process next tuple. */
@@ -1401,7 +1466,11 @@ ExecMergeJoin(PlanState *pstate)
 
 					result = MJFillOuter(node);
 					if (result)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, result);
+#else
 						return result;
+#endif
 				}
 
 				/*
@@ -1415,7 +1484,11 @@ ExecMergeJoin(PlanState *pstate)
 				if (TupIsNull(outerTupleSlot))
 				{
 					MJ_printf("ExecMergeJoin: end of outer subplan\n");
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 
 				/* Else remain in ENDINNER state and process next tuple. */
diff --git a/src/backend/executor/nodeModifyTable.c b/src/backend/executor/nodeModifyTable.c
index 7c6c2c1f6e4..99909638f9c 100644
--- a/src/backend/executor/nodeModifyTable.c
+++ b/src/backend/executor/nodeModifyTable.c
@@ -4172,7 +4172,11 @@ ExecModifyTable(PlanState *pstate)
 	 * extra times.
 	 */
 	if (node->mt_done)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
 	/*
 	 * On first call, fire BEFORE STATEMENT triggers before proceeding.
@@ -4234,7 +4238,11 @@ ExecModifyTable(PlanState *pstate)
 			 * continue the work on next call.
 			 */
 			if (slot)
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, slot);
+#else
 				return slot;
+#endif
 
 			continue;			/* continue with the next tuple */
 		}
@@ -4282,7 +4290,11 @@ ExecModifyTable(PlanState *pstate)
 					 * We'll continue the work on next call.
 					 */
 					if (slot)
+#ifdef DEV3
+						return PostExecProcNodeInstr(pstate, slot);
+#else
 						return slot;
+#endif
 
 					continue;	/* continue with the next tuple */
 				}
@@ -4319,7 +4331,11 @@ ExecModifyTable(PlanState *pstate)
 			slot = ExecProcessReturning(&context, resultRelInfo, operation,
 										NULL, NULL, context.planSlot);
 
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, slot);
+#else
 			return slot;
+#endif
 		}
 
 		EvalPlanQualSetSlot(&node->mt_epqstate, context.planSlot);
@@ -4375,7 +4391,11 @@ ExecModifyTable(PlanState *pstate)
 						 * caller.  We'll continue the work on next call.
 						 */
 						if (slot)
+#ifdef DEV3
+							return PostExecProcNodeInstr(pstate, slot);
+#else
 							return slot;
+#endif
 
 						continue;	/* continue with the next tuple */
 					}
@@ -4432,7 +4452,11 @@ ExecModifyTable(PlanState *pstate)
 						 * caller.  We'll continue the work on next call.
 						 */
 						if (slot)
+#ifdef DEV3
+							return PostExecProcNodeInstr(pstate, slot);
+#else
 							return slot;
+#endif
 
 						continue;	/* continue with the next tuple */
 					}
@@ -4533,7 +4557,11 @@ ExecModifyTable(PlanState *pstate)
 		 * the work on next call.
 		 */
 		if (slot)
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, slot);
+#else
 			return slot;
+#endif
 	}
 
 	/*
@@ -4549,7 +4577,11 @@ ExecModifyTable(PlanState *pstate)
 
 	node->mt_done = true;
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /*
diff --git a/src/backend/executor/nodeNamedtuplestorescan.c b/src/backend/executor/nodeNamedtuplestorescan.c
index 047788d9e4e..828d545d221 100644
--- a/src/backend/executor/nodeNamedtuplestorescan.c
+++ b/src/backend/executor/nodeNamedtuplestorescan.c
@@ -66,11 +66,22 @@ NamedTuplestoreScanRecheck(NamedTuplestoreScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecNamedTuplestoreScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	NamedTuplestoreScanState *node = castNode(NamedTuplestoreScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) NamedTuplestoreScanNext,
+					  (ExecScanRecheckMtd) NamedTuplestoreScanRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) NamedTuplestoreScanNext,
 					(ExecScanRecheckMtd) NamedTuplestoreScanRecheck);
+#endif
 }
 
 
diff --git a/src/backend/executor/nodeNestloop.c b/src/backend/executor/nodeNestloop.c
index 5cd1a251625..9f5ed0e837d 100644
--- a/src/backend/executor/nodeNestloop.c
+++ b/src/backend/executor/nodeNestloop.c
@@ -69,6 +69,9 @@ ExecNestLoop(PlanState *pstate)
 	ExprState  *otherqual;
 	ExprContext *econtext;
 	ListCell   *lc;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -113,7 +116,11 @@ ExecNestLoop(PlanState *pstate)
 			if (TupIsNull(outerTupleSlot))
 			{
 				ENL1_printf("no outer tuple, ending join");
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 			}
 
 			ENL1_printf("saving new outer tuple information");
@@ -188,7 +195,13 @@ ExecNestLoop(PlanState *pstate)
 					 */
 					ENL1_printf("qualification succeeded, projecting tuple");
 
+#ifdef DEV3
+					result = ExecProject(node->js.ps.ps_ProjInfo);
+					return PostExecProcNodeInstr(pstate, result);
+#else
 					return ExecProject(node->js.ps.ps_ProjInfo);
+#endif
+
 				}
 				else
 					InstrCountFiltered2(node, 1);
@@ -237,7 +250,12 @@ ExecNestLoop(PlanState *pstate)
 				 */
 				ENL1_printf("qualification succeeded, projecting tuple");
 
+#ifdef DEV3
+				result = ExecProject(node->js.ps.ps_ProjInfo);
+				return PostExecProcNodeInstr(pstate, result);
+#else
 				return ExecProject(node->js.ps.ps_ProjInfo);
+#endif
 			}
 			else
 				InstrCountFiltered2(node, 1);
diff --git a/src/backend/executor/nodeProjectSet.c b/src/backend/executor/nodeProjectSet.c
index 880f39fb2ff..9e3c7dcda37 100644
--- a/src/backend/executor/nodeProjectSet.c
+++ b/src/backend/executor/nodeProjectSet.c
@@ -68,7 +68,11 @@ ExecProjectSet(PlanState *pstate)
 		resultSlot = ExecProjectSRF(node, true);
 
 		if (resultSlot != NULL)
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, resultSlot);
+#else
 			return resultSlot;
+#endif
 	}
 
 	/*
@@ -94,7 +98,11 @@ ExecProjectSet(PlanState *pstate)
 		outerTupleSlot = ExecProcNode(outerPlan);
 
 		if (TupIsNull(outerTupleSlot))
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 
 		/*
 		 * Prepare to compute projection expressions, which will expect to
@@ -111,7 +119,11 @@ ExecProjectSet(PlanState *pstate)
 		 * more outerPlan tuples.
 		 */
 		if (resultSlot)
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, resultSlot);
+#else
 			return resultSlot;
+#endif
 
 		/*
 		 * When we do loop back, we'd better reset the econtext again, just in
@@ -120,7 +132,11 @@ ExecProjectSet(PlanState *pstate)
 		ResetExprContext(econtext);
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeRecursiveunion.c b/src/backend/executor/nodeRecursiveunion.c
index 40f66fd0680..d06791f8d61 100644
--- a/src/backend/executor/nodeRecursiveunion.c
+++ b/src/backend/executor/nodeRecursiveunion.c
@@ -110,7 +110,11 @@ ExecRecursiveUnion(PlanState *pstate)
 			/* Each non-duplicate tuple goes to the working table ... */
 			tuplestore_puttupleslot(node->working_table, slot);
 			/* ... and to the caller */
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, slot);
+#else
 			return slot;
+#endif
 		}
 		node->recursing = true;
 	}
@@ -166,10 +170,18 @@ ExecRecursiveUnion(PlanState *pstate)
 		node->intermediate_empty = false;
 		tuplestore_puttupleslot(node->intermediate_table, slot);
 		/* ... and return it */
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, slot);
+#else
 		return slot;
+#endif
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeResult.c b/src/backend/executor/nodeResult.c
index 06842a48eca..b9e5bd1e0b9 100644
--- a/src/backend/executor/nodeResult.c
+++ b/src/backend/executor/nodeResult.c
@@ -70,6 +70,9 @@ ExecResult(PlanState *pstate)
 	TupleTableSlot *outerTupleSlot;
 	PlanState  *outerPlan;
 	ExprContext *econtext;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -86,7 +89,11 @@ ExecResult(PlanState *pstate)
 		if (!qualResult)
 		{
 			node->rs_done = true;
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 		}
 	}
 
@@ -114,7 +121,11 @@ ExecResult(PlanState *pstate)
 			outerTupleSlot = ExecProcNode(outerPlan);
 
 			if (TupIsNull(outerTupleSlot))
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 
 			/*
 			 * prepare to compute projection expressions, which will expect to
@@ -132,10 +143,20 @@ ExecResult(PlanState *pstate)
 		}
 
 		/* form the result tuple using ExecProject(), and return it */
+#ifdef DEV3
+		result = ExecProject(node->ps.ps_ProjInfo);
+		return PostExecProcNodeInstr(pstate, result);
+#else
 		return ExecProject(node->ps.ps_ProjInfo);
+#endif
+
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, NULL);
+#else
 	return NULL;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeSamplescan.c b/src/backend/executor/nodeSamplescan.c
index 6b3db7548ed..bea09f10677 100644
--- a/src/backend/executor/nodeSamplescan.c
+++ b/src/backend/executor/nodeSamplescan.c
@@ -78,11 +78,22 @@ SampleRecheck(SampleScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecSampleScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SampleScanState *node = castNode(SampleScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) SampleNext,
+					  (ExecScanRecheckMtd) SampleRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) SampleNext,
 					(ExecScanRecheckMtd) SampleRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeSeqscan.c b/src/backend/executor/nodeSeqscan.c
index ed35c58c2c3..5c417cc7e51 100644
--- a/src/backend/executor/nodeSeqscan.c
+++ b/src/backend/executor/nodeSeqscan.c
@@ -109,18 +109,32 @@ SeqRecheck(SeqScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecSeqScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SeqScanState *node = castNode(SeqScanState, pstate);
 
 	Assert(pstate->state->es_epq_active == NULL);
 	Assert(pstate->qual == NULL);
 	Assert(pstate->ps_ProjInfo == NULL);
 
+#ifdef DEV3
+	result = ExecScanExtended(&node->ss,
+							  (ExecScanAccessMtd) SeqNext,
+							  (ExecScanRecheckMtd) SeqRecheck,
+							  NULL,
+							  NULL,
+							  NULL);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScanExtended(&node->ss,
 							(ExecScanAccessMtd) SeqNext,
 							(ExecScanRecheckMtd) SeqRecheck,
 							NULL,
 							NULL,
 							NULL);
+#endif
 }
 
 /*
@@ -129,18 +143,32 @@ ExecSeqScan(PlanState *pstate)
 static TupleTableSlot *
 ExecSeqScanWithQual(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SeqScanState *node = castNode(SeqScanState, pstate);
 
 	Assert(pstate->state->es_epq_active == NULL);
 	Assert(pstate->qual != NULL);
 	Assert(pstate->ps_ProjInfo == NULL);
 
+#ifdef DEV3
+	result = ExecScanExtended(&node->ss,
+							  (ExecScanAccessMtd) SeqNext,
+							  (ExecScanRecheckMtd) SeqRecheck,
+							  NULL,
+							  pstate->qual,
+							  NULL);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScanExtended(&node->ss,
 							(ExecScanAccessMtd) SeqNext,
 							(ExecScanRecheckMtd) SeqRecheck,
 							NULL,
 							pstate->qual,
 							NULL);
+#endif
 }
 
 /*
@@ -149,18 +177,32 @@ ExecSeqScanWithQual(PlanState *pstate)
 static TupleTableSlot *
 ExecSeqScanWithProject(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SeqScanState *node = castNode(SeqScanState, pstate);
 
 	Assert(pstate->state->es_epq_active == NULL);
 	Assert(pstate->qual == NULL);
 	Assert(pstate->ps_ProjInfo != NULL);
 
+#ifdef DEV3
+	result = ExecScanExtended(&node->ss,
+							  (ExecScanAccessMtd) SeqNext,
+							  (ExecScanRecheckMtd) SeqRecheck,
+							  NULL,
+							  NULL,
+							  pstate->ps_ProjInfo);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScanExtended(&node->ss,
 							(ExecScanAccessMtd) SeqNext,
 							(ExecScanRecheckMtd) SeqRecheck,
 							NULL,
 							NULL,
 							pstate->ps_ProjInfo);
+#endif
 }
 
 /*
@@ -170,18 +212,32 @@ ExecSeqScanWithProject(PlanState *pstate)
 static TupleTableSlot *
 ExecSeqScanWithQualProject(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SeqScanState *node = castNode(SeqScanState, pstate);
 
 	Assert(pstate->state->es_epq_active == NULL);
 	Assert(pstate->qual != NULL);
 	Assert(pstate->ps_ProjInfo != NULL);
 
+#ifdef DEV3
+	result = ExecScanExtended(&node->ss,
+							  (ExecScanAccessMtd) SeqNext,
+							  (ExecScanRecheckMtd) SeqRecheck,
+							  NULL,
+							  pstate->qual,
+							  pstate->ps_ProjInfo);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScanExtended(&node->ss,
 							(ExecScanAccessMtd) SeqNext,
 							(ExecScanRecheckMtd) SeqRecheck,
 							NULL,
 							pstate->qual,
 							pstate->ps_ProjInfo);
+#endif
 }
 
 /*
@@ -192,11 +248,22 @@ ExecSeqScanWithQualProject(PlanState *pstate)
 static TupleTableSlot *
 ExecSeqScanEPQ(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SeqScanState *node = castNode(SeqScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) SeqNext,
+					  (ExecScanRecheckMtd) SeqRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) SeqNext,
 					(ExecScanRecheckMtd) SeqRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeSetOp.c b/src/backend/executor/nodeSetOp.c
index 4068481a523..62d9ffe821e 100644
--- a/src/backend/executor/nodeSetOp.c
+++ b/src/backend/executor/nodeSetOp.c
@@ -159,6 +159,9 @@ set_output_count(SetOpState *setopstate, SetOpStatePerGroup pergroup)
 static TupleTableSlot *			/* return: a tuple or NULL */
 ExecSetOp(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SetOpState *node = castNode(SetOpState, pstate);
 	SetOp	   *plannode = (SetOp *) node->ps.plan;
 	TupleTableSlot *resultTupleSlot = node->ps.ps_ResultTupleSlot;
@@ -172,22 +175,42 @@ ExecSetOp(PlanState *pstate)
 	if (node->numOutput > 0)
 	{
 		node->numOutput--;
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, resultTupleSlot);
+#else
 		return resultTupleSlot;
+#endif
 	}
 
 	/* Otherwise, we're done if we are out of groups */
 	if (node->setop_done)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
 	/* Fetch the next tuple group according to the correct strategy */
 	if (plannode->strategy == SETOP_HASHED)
 	{
 		if (!node->table_filled)
 			setop_fill_hash_table(node);
+#ifdef DEV3
+		result = setop_retrieve_hash_table(node);
+		return PostExecProcNodeInstr(pstate, result);
+#else
 		return setop_retrieve_hash_table(node);
+#endif
 	}
 	else
+	{
+#ifdef DEV3
+		result = setop_retrieve_sorted(node);
+		return PostExecProcNodeInstr(pstate, result);
+#else
 		return setop_retrieve_sorted(node);
+#endif
+	}
 }
 
 /*
diff --git a/src/backend/executor/nodeSort.c b/src/backend/executor/nodeSort.c
index f603337ecd3..f94ca703c06 100644
--- a/src/backend/executor/nodeSort.c
+++ b/src/backend/executor/nodeSort.c
@@ -207,7 +207,11 @@ ExecSort(PlanState *pstate)
 									  ScanDirectionIsForward(dir),
 									  false, slot, NULL);
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, slot);
+#else
 	return slot;
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeSubqueryscan.c b/src/backend/executor/nodeSubqueryscan.c
index 8dd1ae46308..7e36c07452f 100644
--- a/src/backend/executor/nodeSubqueryscan.c
+++ b/src/backend/executor/nodeSubqueryscan.c
@@ -82,11 +82,22 @@ SubqueryRecheck(SubqueryScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecSubqueryScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	SubqueryScanState *node = castNode(SubqueryScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) SubqueryNext,
+					  (ExecScanRecheckMtd) SubqueryRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) SubqueryNext,
 					(ExecScanRecheckMtd) SubqueryRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeTableFuncscan.c b/src/backend/executor/nodeTableFuncscan.c
index 83ade3f9437..2c172c50ede 100644
--- a/src/backend/executor/nodeTableFuncscan.c
+++ b/src/backend/executor/nodeTableFuncscan.c
@@ -96,11 +96,22 @@ TableFuncRecheck(TableFuncScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecTableFuncScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	TableFuncScanState *node = castNode(TableFuncScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) TableFuncNext,
+					  (ExecScanRecheckMtd) TableFuncRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) TableFuncNext,
 					(ExecScanRecheckMtd) TableFuncRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeTidrangescan.c b/src/backend/executor/nodeTidrangescan.c
index 26f7420b64b..8d582b863a6 100644
--- a/src/backend/executor/nodeTidrangescan.c
+++ b/src/backend/executor/nodeTidrangescan.c
@@ -295,11 +295,22 @@ TidRangeRecheck(TidRangeScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecTidRangeScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	TidRangeScanState *node = castNode(TidRangeScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) TidRangeNext,
+					  (ExecScanRecheckMtd) TidRangeRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) TidRangeNext,
 					(ExecScanRecheckMtd) TidRangeRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeTidscan.c b/src/backend/executor/nodeTidscan.c
index 5e56e29a15f..cfbcf69252d 100644
--- a/src/backend/executor/nodeTidscan.c
+++ b/src/backend/executor/nodeTidscan.c
@@ -432,11 +432,22 @@ TidRecheck(TidScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecTidScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	TidScanState *node = castNode(TidScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) TidNext,
+					  (ExecScanRecheckMtd) TidRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) TidNext,
 					(ExecScanRecheckMtd) TidRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeUnique.c b/src/backend/executor/nodeUnique.c
index 3854ad285c4..e03f61ec494 100644
--- a/src/backend/executor/nodeUnique.c
+++ b/src/backend/executor/nodeUnique.c
@@ -50,6 +50,9 @@ ExecUnique(PlanState *pstate)
 	TupleTableSlot *resultTupleSlot;
 	TupleTableSlot *slot;
 	PlanState  *outerPlan;
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 
 	CHECK_FOR_INTERRUPTS();
 
@@ -74,7 +77,11 @@ ExecUnique(PlanState *pstate)
 		{
 			/* end of subplan, so we're done */
 			ExecClearTuple(resultTupleSlot);
+#ifdef DEV3
+			return PostExecProcNodeInstr(pstate, NULL);
+#else
 			return NULL;
+#endif
 		}
 
 		/*
@@ -100,7 +107,12 @@ ExecUnique(PlanState *pstate)
 	 * won't guarantee that this source tuple is still accessible after
 	 * fetching the next source tuple.
 	 */
+#ifdef DEV3
+	result = ExecCopySlot(resultTupleSlot, slot);
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecCopySlot(resultTupleSlot, slot);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeValuesscan.c b/src/backend/executor/nodeValuesscan.c
index 8e85a5f2e9a..074884d065d 100644
--- a/src/backend/executor/nodeValuesscan.c
+++ b/src/backend/executor/nodeValuesscan.c
@@ -195,11 +195,22 @@ ValuesRecheck(ValuesScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecValuesScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	ValuesScanState *node = castNode(ValuesScanState, pstate);
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) ValuesNext,
+					  (ExecScanRecheckMtd) ValuesRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) ValuesNext,
 					(ExecScanRecheckMtd) ValuesRecheck);
+#endif
 }
 
 /* ----------------------------------------------------------------
diff --git a/src/backend/executor/nodeWindowAgg.c b/src/backend/executor/nodeWindowAgg.c
index 9a1acce2b5d..1870f054015 100644
--- a/src/backend/executor/nodeWindowAgg.c
+++ b/src/backend/executor/nodeWindowAgg.c
@@ -2171,7 +2171,11 @@ ExecWindowAgg(PlanState *pstate)
 	CHECK_FOR_INTERRUPTS();
 
 	if (winstate->status == WINDOWAGG_DONE)
+#ifdef DEV3
+		return PostExecProcNodeInstr(pstate, NULL);
+#else
 		return NULL;
+#endif
 
 	/*
 	 * Compute frame offset values, if any, during first call (or after a
@@ -2224,7 +2228,11 @@ ExecWindowAgg(PlanState *pstate)
 			{
 				/* No further partitions?  We're done */
 				winstate->status = WINDOWAGG_DONE;
+#ifdef DEV3
+				return PostExecProcNodeInstr(pstate, NULL);
+#else
 				return NULL;
+#endif
 			}
 		}
 
@@ -2393,7 +2401,11 @@ ExecWindowAgg(PlanState *pstate)
 					 * Nothing else will match the runcondition.
 					 */
 					winstate->status = WINDOWAGG_DONE;
+#ifdef DEV3
+					return PostExecProcNodeInstr(pstate, NULL);
+#else
 					return NULL;
+#endif
 				}
 			}
 
@@ -2417,7 +2429,11 @@ ExecWindowAgg(PlanState *pstate)
 			break;
 	}
 
+#ifdef DEV3
+	return PostExecProcNodeInstr(pstate, slot);
+#else
 	return slot;
+#endif
 }
 
 /* -----------------
diff --git a/src/backend/executor/nodeWorktablescan.c b/src/backend/executor/nodeWorktablescan.c
index f6379c35d2f..c01016af726 100644
--- a/src/backend/executor/nodeWorktablescan.c
+++ b/src/backend/executor/nodeWorktablescan.c
@@ -80,6 +80,9 @@ WorkTableScanRecheck(WorkTableScanState *node, TupleTableSlot *slot)
 static TupleTableSlot *
 ExecWorkTableScan(PlanState *pstate)
 {
+#ifdef DEV3
+	TupleTableSlot *result;
+#endif
 	WorkTableScanState *node = castNode(WorkTableScanState, pstate);
 
 	/*
@@ -116,9 +119,17 @@ ExecWorkTableScan(PlanState *pstate)
 		ExecAssignScanProjectionInfo(&node->ss);
 	}
 
+#ifdef DEV3
+	result = ExecScan(&node->ss,
+					  (ExecScanAccessMtd) WorkTableScanNext,
+					  (ExecScanRecheckMtd) WorkTableScanRecheck);
+
+	return PostExecProcNodeInstr(pstate, result);
+#else
 	return ExecScan(&node->ss,
 					(ExecScanAccessMtd) WorkTableScanNext,
 					(ExecScanRecheckMtd) WorkTableScanRecheck);
+#endif
 }
 
 
diff --git a/src/include/executor/execdesc.h b/src/include/executor/execdesc.h
index 86db3dc8d0d..e1aac4c6d27 100644
--- a/src/include/executor/execdesc.h
+++ b/src/include/executor/execdesc.h
@@ -51,6 +51,7 @@ typedef struct QueryDesc
 	/* This field is set by ExecutePlan */
 	bool		already_executed;	/* true if previously executed */
 
+	uint64_t    hot_instr;		/* bit 0: running, bit 1-63: tuplecount */
 	/* This is always set NULL by the core system, but plugins can change it */
 	struct Instrumentation *totaltime;	/* total time spent in ExecutorRun */
 } QueryDesc;
diff --git a/src/include/executor/executor.h b/src/include/executor/executor.h
index 104b059544d..8446b8c145d 100644
--- a/src/include/executor/executor.h
+++ b/src/include/executor/executor.h
@@ -296,7 +296,6 @@ extern void ExecEndNode(PlanState *node);
 extern void ExecShutdownNode(PlanState *node);
 extern void ExecSetTupleBound(int64 tuples_needed, PlanState *child_node);
 
-
 /* ----------------------------------------------------------------
  *		ExecProcNode
  *
@@ -314,6 +313,43 @@ ExecProcNode(PlanState *node)
 }
 #endif
 
+/* ----------------------------------------------------------------
+ *		PostExecProcNodeInstr
+ *
+ * This is embedded in all ExecXXX functions, such as ExecAgg, ExecAppend,
+ * and so on, and is called before returning their result.
+ *
+ * ----------------------------------------------------------------
+ */
+#define DEV3
+
+#ifdef DEV3
+#ifndef FRONTEND
+static pg_attribute_always_inline TupleTableSlot *
+PostExecProcNodeInstr(PlanState *node, TupleTableSlot *result)
+{
+	uint64_t current = node->hot_instr;
+
+	if ((current & FAST_PATH_INSTR_MASK) == 0) /* is_fast_path_instr_false(node) */
+		return result;
+
+	if (!TupIsNull(result))
+		/* TODO: Prevent overflow */
+		/* Increment tuplecount  + running = true */
+		current = ((current + 1) & TUPLECOUNT_MASK) | (current & (FAST_PATH_INSTR_MASK | RUNNING_MASK));
+
+	/* running = true */
+	current |= RUNNING_MASK;
+
+	/* store current */
+	node->hot_instr = current;
+
+	return result;
+}
+#endif
+#endif
+
+
 /*
  * prototypes from functions in execExpr.c
  */
diff --git a/src/include/executor/instrument.h b/src/include/executor/instrument.h
index 03653ab6c6c..d6e18401fc1 100644
--- a/src/include/executor/instrument.h
+++ b/src/include/executor/instrument.h
@@ -15,7 +15,6 @@
 
 #include "portability/instr_time.h"
 
-
 /*
  * BufferUsage and WalUsage counters keep being incremented infinitely,
  * i.e., must never be reset to zero, so that we can calculate how much
@@ -66,33 +65,39 @@ typedef enum InstrumentOption
 	INSTRUMENT_ALL = PG_INT32_MAX
 } InstrumentOption;
 
+
 typedef struct Instrumentation
 {
+	/*
+	 * These are used exclusively by InstrStopQueryDesc(), which is defined below,
+	 * and ExecParallelReportInstrumentation().
+	 */
+	uint64_t tuplecount;
+	bool running;
 	/* Parameters set at node creation: */
 	bool		need_timer;		/* true if we need timer data */
 	bool		need_bufusage;	/* true if we need buffer usage data */
 	bool		need_walusage;	/* true if we need WAL usage data */
 	bool		async_mode;		/* true if node is in async mode */
 	/* Info about current plan cycle: */
-	bool		running;		/* true if we've completed first tuple */
 	instr_time	starttime;		/* start time of current iteration of node */
 	instr_time	counter;		/* accumulated runtime for this node */
 	double		firsttuple;		/* time for first tuple of this cycle */
-	double		tuplecount;		/* # of tuples emitted so far this cycle */
 	BufferUsage bufusage_start; /* buffer usage at start */
 	WalUsage	walusage_start; /* WAL usage at start */
 	/* Accumulated statistics across all completed cycles: */
 	double		startup;		/* total startup time (in seconds) */
 	double		total;			/* total time (in seconds) */
-	double		ntuples;		/* total tuples produced */
-	double		ntuples2;		/* secondary node-specific tuple counter */
-	double		nloops;			/* # of run cycles for this node */
+	uint64_t 	ntuples;		/* total tuples produced */
+	uint64_t 	ntuples2;		/* secondary node-specific tuple counter */
+	uint64_t 	nloops;			/* # of run cycles for this node */
 	double		nfiltered1;		/* # of tuples removed by scanqual or joinqual */
 	double		nfiltered2;		/* # of tuples removed by "other" quals */
 	BufferUsage bufusage;		/* total buffer usage */
 	WalUsage	walusage;		/* total WAL usage */
 } Instrumentation;
 
+
 typedef struct WorkerInstrumentation
 {
 	int			num_workers;	/* # of structures that follow */
@@ -105,17 +110,81 @@ extern PGDLLIMPORT WalUsage pgWalUsage;
 extern Instrumentation *InstrAlloc(int n, int instrument_options,
 								   bool async_mode);
 extern void InstrInit(Instrumentation *instr, int instrument_options);
-extern void InstrStartNode(Instrumentation *instr);
-extern void InstrStopNode(Instrumentation *instr, double nTuples);
-extern void InstrUpdateTupleCount(Instrumentation *instr, double nTuples);
-extern void InstrEndLoop(Instrumentation *instr);
-extern void InstrAggNode(Instrumentation *dst, Instrumentation *add);
+/* extern void InstrAggNode(Instrumentation *dst, Instrumentation *add);*/
 extern void InstrStartParallelQuery(void);
 extern void InstrEndParallelQuery(BufferUsage *bufusage, WalUsage *walusage);
 extern void InstrAccumParallelQuery(BufferUsage *bufusage, WalUsage *walusage);
+extern void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);
 extern void BufferUsageAccumDiff(BufferUsage *dst,
 								 const BufferUsage *add, const BufferUsage *sub);
+extern void WalUsageAdd(WalUsage *dst, WalUsage *add);
 extern void WalUsageAccumDiff(WalUsage *dst, const WalUsage *add,
 							  const WalUsage *sub);
 
+/* Entry to a plan node */
+static pg_attribute_always_inline void
+InstrStartNode(Instrumentation *instr)
+{
+	if (instr->need_timer &&
+		!INSTR_TIME_SET_CURRENT_LAZY(instr->starttime))
+		elog(ERROR, "InstrStartNode called twice in a row");
+
+	/* save buffer usage totals at node entry, if needed */
+	if (instr->need_bufusage)
+		instr->bufusage_start = pgBufferUsage;
+
+	if (instr->need_walusage)
+		instr->walusage_start = pgWalUsage;
+}
+
+/* Exit from a plan node for standard_ExecutorRun() and standard_ExecutorFinish() */
+static pg_attribute_always_inline void
+InstrStopQueryDesc(Instrumentation *instr, uint64_t nTuples)
+{
+	uint64_t        save_tuplecount = instr->tuplecount;
+	instr_time      endtime;
+
+	/* count the returned tuples */
+	instr->tuplecount +=  nTuples;
+
+	/* let's update the time only if the timer was requested */
+	if (instr->need_timer)
+	{
+		if (INSTR_TIME_IS_ZERO(instr->starttime))
+			elog(ERROR, "InstrStopNode called without start");
+
+		INSTR_TIME_SET_CURRENT(endtime);
+		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
+
+		INSTR_TIME_SET_ZERO(instr->starttime);
+	}
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (instr->need_bufusage)
+		BufferUsageAccumDiff(&instr->bufusage,
+							 &pgBufferUsage, &instr->bufusage_start);
+
+	if (instr->need_walusage)
+		WalUsageAccumDiff(&instr->walusage,
+						  &pgWalUsage, &instr->walusage_start);
+
+	/* Is this the first tuple of this cycle? */
+	if (!instr->running)
+	{
+		instr->running = true;
+		if (instr->need_timer)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+	else
+	{
+		/*
+		 * In async mode, if the plan node hadn't emitted any tuples before,
+		 * this might be the first tuple
+		 */
+		if (instr->need_timer && instr->async_mode && save_tuplecount < 1)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+}
+
+
 #endif							/* INSTRUMENT_H */
diff --git a/src/include/nodes/execnodes.h b/src/include/nodes/execnodes.h
index e107d6e5f81..9f34d5fcea5 100644
--- a/src/include/nodes/execnodes.h
+++ b/src/include/nodes/execnodes.h
@@ -522,6 +522,7 @@ typedef struct ResultRelInfo
 	/* array of trigger WHEN expr states */
 	ExprState **ri_TrigWhenExprs;
 
+	uint64_t    hot_instr;		/* bit 63: fast_path_instr: bit 62: running, bit 0-61: tuplecount */
 	/* optional runtime measurements for triggers */
 	Instrumentation *ri_TrigInstrument;
 
@@ -1171,7 +1172,9 @@ typedef struct PlanState
 	ExecProcNodeMtd ExecProcNodeReal;	/* actual function, if above is a
 										 * wrapper */
 
+	uint64_t    hot_instr;		/* bit 63: fast_path_instr: bit 62: running, bit 0-61: tuplecount */
 	Instrumentation *instrument;	/* Optional runtime stats for this node */
+	uint64_t    worker_hot_instr;
 	WorkerInstrumentation *worker_instrument;	/* per-worker instrumentation */
 
 	/* Per-worker JIT instrumentation */
@@ -2930,4 +2933,220 @@ typedef struct LimitState
 	TupleTableSlot *last_slot;	/* slot for evaluation of ties */
 } LimitState;
 
+
+/* ----------------
+ * hot_instr
+ * ----------------
+ */
+/*
+ * For hot_instr in Instrumentation
+ */
+/* bit definition */
+#define FAST_PATH_INSTR_BIT   63
+#define RUNNING_BIT    62
+
+#define FAST_PATH_INSTR_MASK  (1ULL << FAST_PATH_INSTR_BIT)
+#define RUNNING_MASK   (1ULL << RUNNING_BIT)
+#define TUPLECOUNT_MASK ((1ULL << RUNNING_BIT) - 1)  //(0..61)
+
+// fast_path_instr
+#define is_fast_path_instr_true(node)    (((node)->hot_instr & FAST_PATH_INSTR_MASK) != 0)
+#define is_fast_path_instr_false(node)   (((node)->hot_instr & FAST_PATH_INSTR_MASK) == 0)
+#define set_fast_path_instr_true(node)   ((node)->hot_instr |= FAST_PATH_INSTR_MASK)
+#define set_fast_path_instr_false(node)  ((node)->hot_instr &= ~FAST_PATH_INSTR_MASK)
+
+// running
+#define is_running_true(node)    (((node)->hot_instr & RUNNING_MASK) != 0)
+#define is_running_false(node)   (((node)->hot_instr & RUNNING_MASK) == 0)
+#define set_running_true(node)   ((node)->hot_instr |= RUNNING_MASK)
+#define set_running_false(node)  ((node)->hot_instr &= ~RUNNING_MASK)
+
+// tuplecount
+#define get_tuplecount(node)     ((node)->hot_instr & TUPLECOUNT_MASK)
+#define set_tuplecount(node, n)  \
+	((node)->hot_instr = ((node)->hot_instr & ~TUPLECOUNT_MASK) | ((n) & TUPLECOUNT_MASK))
+#define add_tuplecount(node, n)  \
+	((node)->hot_instr = ((node)->hot_instr & ~TUPLECOUNT_MASK) |		\
+	 (((node)->hot_instr + (n)) & TUPLECOUNT_MASK))
+
+
+/* Exit from a plan node */
+static pg_attribute_always_inline void
+InstrStopNode(PlanState *node, uint64_t nTuples)
+{
+	Instrumentation *instr = node->instrument;
+	uint64_t 	save_tuplecount = get_tuplecount(node);
+	instr_time	endtime;
+
+	add_tuplecount(node, nTuples);
+
+	/* let's update the time only if the timer was requested */
+	if (instr->need_timer)
+	{
+		if (INSTR_TIME_IS_ZERO(instr->starttime))
+			elog(ERROR, "InstrStopNode called without start");
+
+		INSTR_TIME_SET_CURRENT(endtime);
+		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
+
+		INSTR_TIME_SET_ZERO(instr->starttime);
+	}
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (instr->need_bufusage)
+		BufferUsageAccumDiff(&instr->bufusage,
+							 &pgBufferUsage, &instr->bufusage_start);
+
+	if (instr->need_walusage)
+		WalUsageAccumDiff(&instr->walusage,
+						  &pgWalUsage, &instr->walusage_start);
+
+	/* Is this the first tuple of this cycle? */
+	if (is_running_false(node))
+	{
+		set_running_true(node);
+		if (instr->need_timer)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+	else
+	{
+		/*
+		 * In async mode, if the plan node hadn't emitted any tuples before,
+		 * this might be the first tuple
+		 */
+		if (instr->need_timer && instr->async_mode && save_tuplecount < 1)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+}
+
+static pg_attribute_always_inline void
+InstrStopNodeTrigger(ResultRelInfo *relInfo, Instrumentation *instr, uint64_t nTuples)
+{
+	uint64_t		save_tuplecount = get_tuplecount(relInfo);
+	instr_time	endtime;
+
+	/* count the returned tuples */
+	add_tuplecount(relInfo, nTuples);
+	instr->tuplecount = get_tuplecount(relInfo);;
+
+	/* let's update the time only if the timer was requested */
+	if (instr->need_timer)
+	{
+		if (INSTR_TIME_IS_ZERO(instr->starttime))
+			elog(ERROR, "InstrStopNode called without start");
+
+		INSTR_TIME_SET_CURRENT(endtime);
+		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
+
+		INSTR_TIME_SET_ZERO(instr->starttime);
+	}
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (instr->need_bufusage)
+		BufferUsageAccumDiff(&instr->bufusage,
+							 &pgBufferUsage, &instr->bufusage_start);
+
+	if (instr->need_walusage)
+		WalUsageAccumDiff(&instr->walusage,
+						  &pgWalUsage, &instr->walusage_start);
+
+	/* Is this the first tuple of this cycle? */
+	if (!is_running_true(relInfo))
+	{
+		set_running_true(relInfo);
+		instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+	else
+	{
+		/*
+		 * In async mode, if the plan node hadn't emitted any tuples before,
+		 * this might be the first tuple
+		 */
+		if (instr->async_mode && save_tuplecount < 1)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+}
+
+/* Update tuple count */
+static pg_attribute_always_inline void
+InstrUpdateTupleCount(PlanState *node, uint64_t nTuples)
+{
+	/* count the returned tuples */
+	add_tuplecount(node, nTuples);
+}
+
+
+/* Finish a run cycle for a plan node */
+static pg_attribute_always_inline void
+InstrEndLoop(PlanState *node)
+{
+	double		totaltime;
+	Instrumentation *instr = node->instrument;
+
+	/* Skip if nothing has happened, or already shut down */
+	if (!is_running_true(node))
+		return;
+
+	if (!INSTR_TIME_IS_ZERO(instr->starttime))
+		elog(ERROR, "InstrEndLoop called on running node");
+
+	/* Accumulate per-cycle statistics into totals */
+	if (instr->need_timer)
+	{
+		totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
+
+		instr->startup += instr->firsttuple;
+		instr->total += totaltime;
+	}
+	instr->ntuples += get_tuplecount(node);
+	instr->nloops += 1;
+
+	/* Reset for next cycle (if any) */
+	set_running_false(node);
+	if (instr->need_timer)
+	{
+		INSTR_TIME_SET_ZERO(instr->starttime);
+		INSTR_TIME_SET_ZERO(instr->counter);
+		instr->firsttuple = 0;
+	}
+	set_tuplecount(node, 0);
+}
+
+/* Finish a run cycle for a plan node */
+static pg_attribute_always_inline void
+InstrEndLoopResultRelInfo(ResultRelInfo *rInfo, Instrumentation *instr)
+{
+	double		totaltime;
+
+	/* Skip if nothing has happened, or already shut down */
+	if (!instr->running)
+		return;
+
+	if (!INSTR_TIME_IS_ZERO(instr->starttime))
+		elog(ERROR, "InstrEndLoop called on running node");
+
+	/* Accumulate per-cycle statistics into totals */
+	if (instr->need_timer)
+	{
+		totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
+
+		instr->startup += instr->firsttuple;
+		instr->total += totaltime;
+	}
+	instr->ntuples += get_tuplecount(rInfo);
+	instr->nloops += 1;
+
+	/* Reset for next cycle (if any) */
+	set_running_false(rInfo);
+	instr->running = false;
+	if (instr->need_timer)
+	{
+		INSTR_TIME_SET_ZERO(instr->starttime);
+		INSTR_TIME_SET_ZERO(instr->counter);
+		instr->firsttuple = 0;
+	}
+	set_tuplecount(rInfo, 0);
+	instr->tuplecount = 0;
+}
+
 #endif							/* EXECNODES_H */
