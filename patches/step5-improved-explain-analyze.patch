diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index b6a04454ffd..caae15f8a67 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -1103,7 +1103,7 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 		char	   *conname = NULL;
 
 		/* Must clean up instrumentation state */
-		InstrEndLoop(instr);
+		InstrEndLoopResultRelInfo(rInfo, instr);
 
 		/*
 		 * We ignore triggers that were never invoked; they likely aren't
@@ -1824,7 +1824,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 	 * auto_explain has to contend with.
 	 */
 	if (planstate->instrument)
-		InstrEndLoop(planstate->instrument);
+		InstrEndLoop(planstate);
 
 	if (es->analyze &&
 		planstate->instrument && planstate->instrument->nloops > 0)
@@ -4695,7 +4695,7 @@ show_modifytable_info(ModifyTableState *mtstate, List *ancestors,
 			uint64_t 	insert_path;
 			uint64_t 	other_path;
 
-			InstrEndLoop(outerPlanState(mtstate)->instrument);
+			InstrEndLoop(outerPlanState(mtstate));
 
 			/* count the number of source rows */
 			total = outerPlanState(mtstate)->instrument->ntuples;
@@ -4719,7 +4719,7 @@ show_modifytable_info(ModifyTableState *mtstate, List *ancestors,
 			uint64_t 	delete_path;
 			uint64_t 	skipped_path;
 
-			InstrEndLoop(outerPlanState(mtstate)->instrument);
+			InstrEndLoop(outerPlanState(mtstate));
 
 			/* count the number of source rows */
 			total = outerPlanState(mtstate)->instrument->ntuples;
diff --git a/src/backend/commands/trigger.c b/src/backend/commands/trigger.c
index 7dc121f73f1..08168633060 100644
--- a/src/backend/commands/trigger.c
+++ b/src/backend/commands/trigger.c
@@ -89,6 +89,7 @@ static bool TriggerEnabled(EState *estate, ResultRelInfo *relinfo,
 						   Bitmapset *modifiedCols,
 						   TupleTableSlot *oldslot, TupleTableSlot *newslot);
 static HeapTuple ExecCallTriggerFunc(TriggerData *trigdata,
+									 ResultRelInfo *relInfo,
 									 int tgindx,
 									 FmgrInfo *finfo,
 									 Instrumentation *instr,
@@ -2306,6 +2307,7 @@ FindTriggerIncompatibleWithInheritance(TriggerDesc *trigdesc)
  */
 static HeapTuple
 ExecCallTriggerFunc(TriggerData *trigdata,
+					ResultRelInfo *relInfo,
 					int tgindx,
 					FmgrInfo *finfo,
 					Instrumentation *instr,
@@ -2390,8 +2392,8 @@ ExecCallTriggerFunc(TriggerData *trigdata,
 	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
 	 * one "tuple returned" (really the number of firings).
 	 */
-	if (instr)
-		InstrStopNode(instr + tgindx, 1);
+	if (instr && relInfo != NULL)
+		InstrStopNodeTrigger(relInfo, instr + tgindx, 1);
 
 	return (HeapTuple) DatumGetPointer(result);
 }
@@ -2435,6 +2437,7 @@ ExecBSInsertTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2496,6 +2499,7 @@ ExecBRInsertTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = oldtuple = newtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2591,6 +2595,7 @@ ExecIRInsertTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = oldtuple = newtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2655,6 +2660,7 @@ ExecBSDeleteTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2765,6 +2771,7 @@ ExecBRDeleteTriggers(EState *estate, EPQState *epqstate,
 		LocTriggerData.tg_trigtuple = trigtuple;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2860,6 +2867,7 @@ ExecIRDeleteTriggers(EState *estate, ResultRelInfo *relinfo,
 		LocTriggerData.tg_trigtuple = trigtuple;
 		LocTriggerData.tg_trigger = trigger;
 		rettuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -2918,6 +2926,7 @@ ExecBSUpdateTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3070,6 +3079,7 @@ ExecBRUpdateTriggers(EState *estate, EPQState *epqstate,
 		LocTriggerData.tg_newslot = newslot;
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3224,6 +3234,7 @@ ExecIRUpdateTriggers(EState *estate, ResultRelInfo *relinfo,
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -3282,6 +3293,7 @@ ExecBSTruncateTriggers(EState *estate, ResultRelInfo *relinfo)
 
 		LocTriggerData.tg_trigger = trigger;
 		newtuple = ExecCallTriggerFunc(&LocTriggerData,
+									   relinfo,
 									   i,
 									   relinfo->ri_TrigFunctions,
 									   relinfo->ri_TrigInstrument,
@@ -4543,6 +4555,7 @@ AfterTriggerExecute(EState *estate,
 	 * (Don't let ExecCallTriggerFunc measure EXPLAIN time.)
 	 */
 	rettuple = ExecCallTriggerFunc(&LocTriggerData,
+								   NULL,
 								   tgindx,
 								   finfo,
 								   NULL,
@@ -4577,8 +4590,8 @@ AfterTriggerExecute(EState *estate,
 	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
 	 * one "tuple returned" (really the number of firings).
 	 */
-	if (instr)
-		InstrStopNode(instr + tgindx, 1);
+	if (instr && relInfo != NULL)
+		InstrStopNodeTrigger(relInfo, instr + tgindx, 1);
 }
 
 
diff --git a/src/backend/executor/execAmi.c b/src/backend/executor/execAmi.c
index 1d0e8ad57b4..6200d8e995b 100644
--- a/src/backend/executor/execAmi.c
+++ b/src/backend/executor/execAmi.c
@@ -78,7 +78,7 @@ ExecReScan(PlanState *node)
 {
 	/* If collecting timing stats, update them */
 	if (node->instrument)
-		InstrEndLoop(node->instrument);
+		InstrEndLoop(node);
 
 	/*
 	 * If we have changed parameters, propagate that info.
diff --git a/src/backend/executor/execAsync.c b/src/backend/executor/execAsync.c
index 2e7e2e8874e..1912e130275 100644
--- a/src/backend/executor/execAsync.c
+++ b/src/backend/executor/execAsync.c
@@ -47,7 +47,7 @@ ExecAsyncRequest(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument,
+		InstrStopNode(areq->requestee,
 					  TupIsNull(areq->result) ? 0 : 1);
 }
 
@@ -78,7 +78,7 @@ ExecAsyncConfigureWait(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument, 0);
+		InstrStopNode(areq->requestee, 0);
 }
 
 /*
@@ -106,7 +106,7 @@ ExecAsyncNotify(AsyncRequest *areq)
 
 	/* must provide our own instrumentation support */
 	if (areq->requestee->instrument)
-		InstrStopNode(areq->requestee->instrument,
+		InstrStopNode(areq->requestee,
 					  TupIsNull(areq->result) ? 0 : 1);
 }
 
diff --git a/src/backend/executor/execMain.c b/src/backend/executor/execMain.c
index 740a0b64758..05a3d22e231 100644
--- a/src/backend/executor/execMain.c
+++ b/src/backend/executor/execMain.c
@@ -388,7 +388,7 @@ standard_ExecutorRun(QueryDesc *queryDesc,
 		dest->rShutdown(dest);
 
 	if (queryDesc->totaltime)
-		InstrStopNode(queryDesc->totaltime, estate->es_processed);
+		InstrStopQueryDesc(queryDesc->totaltime, estate->es_processed);
 
 	MemoryContextSwitchTo(oldcontext);
 }
@@ -448,7 +448,7 @@ standard_ExecutorFinish(QueryDesc *queryDesc)
 		AfterTriggerEndQuery(estate);
 
 	if (queryDesc->totaltime)
-		InstrStopNode(queryDesc->totaltime, 0);
+		InstrStopQueryDesc(queryDesc->totaltime, 0);
 
 	MemoryContextSwitchTo(oldcontext);
 
diff --git a/src/backend/executor/execParallel.c b/src/backend/executor/execParallel.c
index f098a5557cf..c7af573a646 100644
--- a/src/backend/executor/execParallel.c
+++ b/src/backend/executor/execParallel.c
@@ -139,6 +139,71 @@ static bool ExecParallelRetrieveInstrumentation(PlanState *planstate,
 /* Helper function that runs in the parallel worker. */
 static DestReceiver *ExecParallelGetReceiver(dsm_segment *seg, shm_toc *toc);
 
+/* aggregate instrumentation information */
+static void
+InstrAggNode(Instrumentation *dst, Instrumentation *add)
+{
+	if (!dst->running && add->running)
+	{
+		dst->running = true;
+		dst->firsttuple = add->firsttuple;
+	}
+	else if (dst->running && add->running && dst->firsttuple > add->firsttuple)
+		dst->firsttuple = add->firsttuple;
+
+	INSTR_TIME_ADD(dst->counter, add->counter);
+
+	dst->tuplecount += add->tuplecount;
+	dst->startup += add->startup;
+	dst->total += add->total;
+	dst->ntuples += add->ntuples;
+	dst->ntuples2 += add->ntuples2;
+	dst->nloops += add->nloops;
+	dst->nfiltered1 += add->nfiltered1;
+	dst->nfiltered2 += add->nfiltered2;
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (dst->need_bufusage)
+		BufferUsageAdd(&dst->bufusage, &add->bufusage);
+
+	if (dst->need_walusage)
+		WalUsageAdd(&dst->walusage, &add->walusage);
+}
+
+static void
+InstrAggNodePlanState(PlanState *node_dst, Instrumentation *add)
+{
+	Instrumentation *dst = node_dst->instrument;
+
+	if (!dst->running && add->running)
+	{
+		dst->running = true;
+		set_running_true(node_dst);
+		dst->firsttuple = add->firsttuple;
+	}
+	else if (dst->running && add->running && dst->firsttuple > add->firsttuple)
+		dst->firsttuple = add->firsttuple;
+
+	INSTR_TIME_ADD(dst->counter, add->counter);
+
+	dst->tuplecount += add->tuplecount;
+	add_tuplecount(node_dst, add->tuplecount);
+	dst->startup += add->startup;
+	dst->total += add->total;
+	dst->ntuples += add->ntuples;
+	dst->ntuples2 += add->ntuples2;
+	dst->nloops += add->nloops;
+	dst->nfiltered1 += add->nfiltered1;
+	dst->nfiltered2 += add->nfiltered2;
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (dst->need_bufusage)
+		BufferUsageAdd(&dst->bufusage, &add->bufusage);
+
+	if (dst->need_walusage)
+		WalUsageAdd(&dst->walusage, &add->walusage);
+}
+
 /*
  * Create a serialized representation of the plan to be sent to each worker.
  */
@@ -1054,7 +1119,7 @@ ExecParallelRetrieveInstrumentation(PlanState *planstate,
 	instrument = GetInstrumentationArray(instrumentation);
 	instrument += i * instrumentation->num_workers;
 	for (n = 0; n < instrumentation->num_workers; ++n)
-		InstrAggNode(planstate->instrument, &instrument[n]);
+		InstrAggNodePlanState(planstate, &instrument[n]);
 
 	/*
 	 * Also store the per-worker detail.
@@ -1298,7 +1363,7 @@ ExecParallelReportInstrumentation(PlanState *planstate,
 	int			plan_node_id = planstate->plan->plan_node_id;
 	Instrumentation *instrument;
 
-	InstrEndLoop(planstate->instrument);
+	InstrEndLoop(planstate);
 
 	/*
 	 * If we shuffled the plan_node_id values in ps_instrument into sorted
@@ -1320,6 +1385,14 @@ ExecParallelReportInstrumentation(PlanState *planstate,
 	instrument += i * instrumentation->num_workers;
 	Assert(IsParallelWorker());
 	Assert(ParallelWorkerNumber < instrumentation->num_workers);
+
+	/*
+	 * To aggregate the data, we temporarily restore the tuplecount and running
+	 * fields to the Instrument structure.
+	 */
+	planstate->instrument->tuplecount = get_tuplecount(planstate);
+	planstate->instrument->running = is_running_true(planstate) ? true : false;
+
 	InstrAggNode(&instrument[ParallelWorkerNumber], planstate->instrument);
 
 	return planstate_tree_walker(planstate, ExecParallelReportInstrumentation,
diff --git a/src/backend/executor/execProcnode.c b/src/backend/executor/execProcnode.c
index 19a1f6d0321..de3367e03fa 100644
--- a/src/backend/executor/execProcnode.c
+++ b/src/backend/executor/execProcnode.c
@@ -516,7 +516,7 @@ ExecProcNodeInstr(PlanState *node)
 
 	result = node->ExecProcNodeReal(node);
 
-	InstrStopNode(node->instrument, TupIsNull(result) ? 0 : 1);
+	InstrStopNode(node, TupIsNull(result) ? 0 : 1);
 
 	return result;
 }
@@ -853,7 +853,7 @@ ExecShutdownNode_walker(PlanState *node, void *context)
 	 * has never been executed, so as to avoid incorrectly making it appear
 	 * that it has.
 	 */
-	if (node->instrument && is_running_true(node->instrument))
+	if (node->instrument && is_running_true(node))
 		InstrStartNode(node->instrument);
 
 	planstate_tree_walker(node, ExecShutdownNode_walker, context);
@@ -883,8 +883,8 @@ ExecShutdownNode_walker(PlanState *node, void *context)
 	}
 
 	/* Stop the node if we started it above, reporting 0 tuples. */
-	if (node->instrument && is_running_true(node->instrument))
-		InstrStopNode(node->instrument, 0);
+	if (node->instrument && is_running_true(node))
+		InstrStopNode(node, 0);
 
 	return false;
 }
diff --git a/src/backend/executor/instrument.c b/src/backend/executor/instrument.c
index c9403db1839..52a13111747 100644
--- a/src/backend/executor/instrument.c
+++ b/src/backend/executor/instrument.c
@@ -22,8 +22,8 @@ static BufferUsage save_pgBufferUsage;
 WalUsage	pgWalUsage;
 static WalUsage save_pgWalUsage;
 
-static void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);
-static void WalUsageAdd(WalUsage *dst, WalUsage *add);
+/*static void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);*/
+/*static void WalUsageAdd(WalUsage *dst, WalUsage *add);*/
 
 
 /* Allocate new instrumentation structure(s) */
@@ -75,36 +75,6 @@ InstrInit(Instrumentation *instr, int instrument_options)
 #endif
 }
 
-/* aggregate instrumentation information */
-void
-InstrAggNode(Instrumentation *dst, Instrumentation *add)
-{
-	if (!is_running_true(dst) && is_running_true(add))
-	{
-		set_running_true(dst);
-		dst->firsttuple = add->firsttuple;
-	}
-	else if (is_running_true(dst) && is_running_true(add) && dst->firsttuple > add->firsttuple)
-		dst->firsttuple = add->firsttuple;
-
-	INSTR_TIME_ADD(dst->counter, add->counter);
-
-	add_tuplecount(dst, get_tuplecount(add));
-	dst->startup += add->startup;
-	dst->total += add->total;
-	dst->ntuples += add->ntuples;
-	dst->ntuples2 += add->ntuples2;
-	dst->nloops += add->nloops;
-	dst->nfiltered1 += add->nfiltered1;
-	dst->nfiltered2 += add->nfiltered2;
-
-	/* Add delta of buffer usage since entry to node's totals */
-	if (dst->need_bufusage)
-		BufferUsageAdd(&dst->bufusage, &add->bufusage);
-
-	if (dst->need_walusage)
-		WalUsageAdd(&dst->walusage, &add->walusage);
-}
 
 /* note current values during parallel executor startup */
 void
@@ -133,7 +103,7 @@ InstrAccumParallelQuery(BufferUsage *bufusage, WalUsage *walusage)
 }
 
 /* dst += add */
-static void
+void
 BufferUsageAdd(BufferUsage *dst, const BufferUsage *add)
 {
 	dst->shared_blks_hit += add->shared_blks_hit;
@@ -185,7 +155,7 @@ BufferUsageAccumDiff(BufferUsage *dst,
 }
 
 /* helper functions for WAL usage accumulation */
-static void
+void
 WalUsageAdd(WalUsage *dst, WalUsage *add)
 {
 	dst->wal_bytes += add->wal_bytes;
diff --git a/src/backend/executor/nodeBitmapAnd.c b/src/backend/executor/nodeBitmapAnd.c
index 0a9e56505bd..682bc00207a 100644
--- a/src/backend/executor/nodeBitmapAnd.c
+++ b/src/backend/executor/nodeBitmapAnd.c
@@ -165,7 +165,7 @@ MultiExecBitmapAnd(BitmapAndState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, 0 /* XXX */ );
+		InstrStopNode(&node->ps, 0 /* XXX */ );
 
 	return (Node *) result;
 }
diff --git a/src/backend/executor/nodeBitmapIndexscan.c b/src/backend/executor/nodeBitmapIndexscan.c
index 0dc0dff3e33..f4ad83ea347 100644
--- a/src/backend/executor/nodeBitmapIndexscan.c
+++ b/src/backend/executor/nodeBitmapIndexscan.c
@@ -119,7 +119,7 @@ MultiExecBitmapIndexScan(BitmapIndexScanState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ss.ps.instrument)
-		InstrStopNode(node->ss.ps.instrument, nTuples);
+		InstrStopNode(&node->ss.ps, nTuples);
 
 	return (Node *) tbm;
 }
diff --git a/src/backend/executor/nodeBitmapOr.c b/src/backend/executor/nodeBitmapOr.c
index 186024987c2..714393c112c 100644
--- a/src/backend/executor/nodeBitmapOr.c
+++ b/src/backend/executor/nodeBitmapOr.c
@@ -183,7 +183,7 @@ MultiExecBitmapOr(BitmapOrState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, 0 /* XXX */ );
+		InstrStopNode(&node->ps, 0 /* XXX */ );
 
 	return (Node *) result;
 }
diff --git a/src/backend/executor/nodeHash.c b/src/backend/executor/nodeHash.c
index 898001a7417..9e2af970ed7 100644
--- a/src/backend/executor/nodeHash.c
+++ b/src/backend/executor/nodeHash.c
@@ -119,7 +119,7 @@ MultiExecHash(HashState *node)
 
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
-		InstrStopNode(node->ps.instrument, node->hashtable->partialTuples);
+		InstrStopNode(&node->ps, node->hashtable->partialTuples);
 
 	/*
 	 * We do not return the hash table directly because it's not a subtype of
diff --git a/src/include/executor/execdesc.h b/src/include/executor/execdesc.h
index 86db3dc8d0d..e1aac4c6d27 100644
--- a/src/include/executor/execdesc.h
+++ b/src/include/executor/execdesc.h
@@ -51,6 +51,7 @@ typedef struct QueryDesc
 	/* This field is set by ExecutePlan */
 	bool		already_executed;	/* true if previously executed */
 
+	uint64_t    hot_instr;		/* bit 0: running, bit 1-63: tuplecount */
 	/* This is always set NULL by the core system, but plugins can change it */
 	struct Instrumentation *totaltime;	/* total time spent in ExecutorRun */
 } QueryDesc;
diff --git a/src/include/executor/executor.h b/src/include/executor/executor.h
index 30a61422329..47edf777b5b 100644
--- a/src/include/executor/executor.h
+++ b/src/include/executor/executor.h
@@ -328,14 +328,7 @@ ExecProcNode(PlanState *node)
 static pg_attribute_always_inline TupleTableSlot *
 PostExecProcNodeInstr(PlanState *node, TupleTableSlot *result)
 {
-	uint64_t current;
-	Instrumentation *instr = node->instrument;
-
-	/* Most common case: no instrumentation */
-	if (!instr)
-		return result;
-
-	current = instr->hot_instr;
+	uint64_t current = node->hot_instr;
 
 	if (!TupIsNull(result))
 		/* Increment tuplecount  + running = true */
@@ -345,7 +338,7 @@ PostExecProcNodeInstr(PlanState *node, TupleTableSlot *result)
 		current |= RUNNING_MASK;
 
 	/* store current */
-	instr->hot_instr = current;
+	node->hot_instr = current;
 
 	return result;
 }
diff --git a/src/include/executor/instrument.h b/src/include/executor/instrument.h
index 80af0040993..d6e18401fc1 100644
--- a/src/include/executor/instrument.h
+++ b/src/include/executor/instrument.h
@@ -15,7 +15,6 @@
 
 #include "portability/instr_time.h"
 
-
 /*
  * BufferUsage and WalUsage counters keep being incremented infinitely,
  * i.e., must never be reset to zero, so that we can calculate how much
@@ -69,8 +68,12 @@ typedef enum InstrumentOption
 
 typedef struct Instrumentation
 {
-	uint64_t    hot_instr;		/* bit 0: running, bit 1-63: tuplecount */
-
+	/*
+	 * These are used exclusively by InstrStopQueryDesc(), which is defined below,
+	 * and ExecParallelReportInstrumentation().
+	 */
+	uint64_t tuplecount;
+	bool running;
 	/* Parameters set at node creation: */
 	bool		need_timer;		/* true if we need timer data */
 	bool		need_bufusage;	/* true if we need buffer usage data */
@@ -95,33 +98,6 @@ typedef struct Instrumentation
 } Instrumentation;
 
 
-/*
- * For hot_instr in Instrumentation
- */
-/* bit definition */
-#define RUNNING_BIT         63
-#define RUNNING_MASK        (1ULL << RUNNING_BIT)
-#define TUPLECOUNT_MASK     (~RUNNING_MASK)
-#define MAX_TUPLECOUNT      ((1ULL << 63) - 1)
-
-/* running flag operation */
-#define is_running_true(instr)      (((instr)->hot_instr & RUNNING_MASK) != 0)
-#define set_running_true(instr)     ((instr)->hot_instr |= RUNNING_MASK)
-#define set_running_false(instr)    ((instr)->hot_instr &= TUPLECOUNT_MASK)
-
-/* tuplecount operation */
-#define get_tuplecount(instr)       ((instr)->hot_instr & TUPLECOUNT_MASK)
-#define set_tuplecount(instr, n)    do { \
-		(instr)->hot_instr = ((instr)->hot_instr & RUNNING_MASK) | ((n) & TUPLECOUNT_MASK); \
-} while(0)
-
-#define add_tuplecount(instr, n)    do { \
-		uint64_t current = get_tuplecount(instr);						\
-	uint64_t new_count = (current + (n)) & TUPLECOUNT_MASK;				\
-	(instr)->hot_instr = ((instr)->hot_instr & RUNNING_MASK) | new_count; \
-} while(0)
-
-
 typedef struct WorkerInstrumentation
 {
 	int			num_workers;	/* # of structures that follow */
@@ -134,12 +110,14 @@ extern PGDLLIMPORT WalUsage pgWalUsage;
 extern Instrumentation *InstrAlloc(int n, int instrument_options,
 								   bool async_mode);
 extern void InstrInit(Instrumentation *instr, int instrument_options);
-extern void InstrAggNode(Instrumentation *dst, Instrumentation *add);
+/* extern void InstrAggNode(Instrumentation *dst, Instrumentation *add);*/
 extern void InstrStartParallelQuery(void);
 extern void InstrEndParallelQuery(BufferUsage *bufusage, WalUsage *walusage);
 extern void InstrAccumParallelQuery(BufferUsage *bufusage, WalUsage *walusage);
+extern void BufferUsageAdd(BufferUsage *dst, const BufferUsage *add);
 extern void BufferUsageAccumDiff(BufferUsage *dst,
 								 const BufferUsage *add, const BufferUsage *sub);
+extern void WalUsageAdd(WalUsage *dst, WalUsage *add);
 extern void WalUsageAccumDiff(WalUsage *dst, const WalUsage *add,
 							  const WalUsage *sub);
 
@@ -159,18 +137,15 @@ InstrStartNode(Instrumentation *instr)
 		instr->walusage_start = pgWalUsage;
 }
 
-/* Exit from a plan node */
+/* Exit from a plan node for standard_ExecutorRun() and standard_ExecutorFinish() */
 static pg_attribute_always_inline void
-InstrStopNode(Instrumentation *instr, uint64_t nTuples)
+InstrStopQueryDesc(Instrumentation *instr, uint64_t nTuples)
 {
-	uint64_t 	save_tuplecount = get_tuplecount(instr);
-	instr_time	endtime;
+	uint64_t        save_tuplecount = instr->tuplecount;
+	instr_time      endtime;
 
-	/*
-	 * We omit adding nTuples, as the ExecXX function family already
-	 * increments nTuples.
-	 * instr->tuplecount += nTuples;
-	 */
+	/* count the returned tuples */
+	instr->tuplecount +=  nTuples;
 
 	/* let's update the time only if the timer was requested */
 	if (instr->need_timer)
@@ -194,9 +169,9 @@ InstrStopNode(Instrumentation *instr, uint64_t nTuples)
 						  &pgWalUsage, &instr->walusage_start);
 
 	/* Is this the first tuple of this cycle? */
-	if (!is_running_true(instr))
+	if (!instr->running)
 	{
-		set_running_true(instr);
+		instr->running = true;
 		if (instr->need_timer)
 			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
 	}
@@ -211,48 +186,5 @@ InstrStopNode(Instrumentation *instr, uint64_t nTuples)
 	}
 }
 
-/* Update tuple count */
-static pg_attribute_always_inline void
-InstrUpdateTupleCount(Instrumentation *instr, uint64_t nTuples)
-{
-	/* count the returned tuples */
-	add_tuplecount(instr, nTuples);
-}
-
-
-/* Finish a run cycle for a plan node */
-static pg_attribute_always_inline void
-InstrEndLoop(Instrumentation *instr)
-{
-	double		totaltime;
-
-	/* Skip if nothing has happened, or already shut down */
-	if (!is_running_true(instr))
-		return;
-
-	if (!INSTR_TIME_IS_ZERO(instr->starttime))
-		elog(ERROR, "InstrEndLoop called on running node");
-
-	/* Accumulate per-cycle statistics into totals */
-	if (instr->need_timer)
-	{
-		totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
-
-		instr->startup += instr->firsttuple;
-		instr->total += totaltime;
-	}
-	instr->ntuples += get_tuplecount(instr);
-	instr->nloops += 1;
-
-	/* Reset for next cycle (if any) */
-	set_running_false(instr);
-	if (instr->need_timer)
-	{
-		INSTR_TIME_SET_ZERO(instr->starttime);
-		INSTR_TIME_SET_ZERO(instr->counter);
-		instr->firsttuple = 0;
-	}
-	set_tuplecount(instr, 0);
-}
 
 #endif							/* INSTRUMENT_H */
diff --git a/src/include/nodes/execnodes.h b/src/include/nodes/execnodes.h
index e107d6e5f81..618843fb459 100644
--- a/src/include/nodes/execnodes.h
+++ b/src/include/nodes/execnodes.h
@@ -522,6 +522,7 @@ typedef struct ResultRelInfo
 	/* array of trigger WHEN expr states */
 	ExprState **ri_TrigWhenExprs;
 
+	uint64_t    hot_instr;		/* bit 0: running, bit 1-63: tuplecount */
 	/* optional runtime measurements for triggers */
 	Instrumentation *ri_TrigInstrument;
 
@@ -1171,7 +1172,9 @@ typedef struct PlanState
 	ExecProcNodeMtd ExecProcNodeReal;	/* actual function, if above is a
 										 * wrapper */
 
+	uint64_t    hot_instr;		/* bit 0: running, bit 1-63: tuplecount */
 	Instrumentation *instrument;	/* Optional runtime stats for this node */
+	uint64_t    worker_hot_instr;
 	WorkerInstrumentation *worker_instrument;	/* per-worker instrumentation */
 
 	/* Per-worker JIT instrumentation */
@@ -2930,4 +2933,218 @@ typedef struct LimitState
 	TupleTableSlot *last_slot;	/* slot for evaluation of ties */
 } LimitState;
 
+
+/* ----------------
+ * hot_instr
+ * ----------------
+ */
+/*
+ * For hot_instr in Instrumentation
+ */
+/* bit definition */
+#define RUNNING_BIT         63
+#define RUNNING_MASK        (1ULL << RUNNING_BIT)
+#define TUPLECOUNT_MASK     (~RUNNING_MASK)
+#define MAX_TUPLECOUNT      ((1ULL << 63) - 1)
+
+/* running flag operation */
+#define is_running_true(node)      (((node)->hot_instr & RUNNING_MASK) != 0)
+#define set_running_true(node)     ((node)->hot_instr |= RUNNING_MASK)
+#define set_running_false(node)    ((node)->hot_instr &= TUPLECOUNT_MASK)
+
+/* tuplecount operation */
+#define get_tuplecount(node)       ((node)->hot_instr & TUPLECOUNT_MASK)
+#define set_tuplecount(node, n)    do { \
+		(node)->hot_instr = ((node)->hot_instr & RUNNING_MASK) | ((n) & TUPLECOUNT_MASK); \
+} while(0)
+
+#define add_tuplecount(node, n)    do { \
+		uint64_t current = get_tuplecount(node);						\
+	uint64_t new_count = (current + (n)) & TUPLECOUNT_MASK;				\
+	(node)->hot_instr = ((node)->hot_instr & RUNNING_MASK) | new_count; \
+} while(0)
+
+/* Exit from a plan node */
+static pg_attribute_always_inline void
+InstrStopNode(PlanState *node, uint64_t nTuples)
+{
+	Instrumentation *instr = node->instrument;
+	uint64_t 	save_tuplecount = get_tuplecount(node);
+	instr_time	endtime;
+
+	/*
+	 * We omit adding nTuples, as the ExecXX function family already
+	 * increments nTuples.
+	 * 	add_tuplecount(node, nTuples);
+	 */
+
+	/* let's update the time only if the timer was requested */
+	if (instr->need_timer)
+	{
+		if (INSTR_TIME_IS_ZERO(instr->starttime))
+			elog(ERROR, "InstrStopNode called without start");
+
+		INSTR_TIME_SET_CURRENT(endtime);
+		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
+
+		INSTR_TIME_SET_ZERO(instr->starttime);
+	}
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (instr->need_bufusage)
+		BufferUsageAccumDiff(&instr->bufusage,
+							 &pgBufferUsage, &instr->bufusage_start);
+
+	if (instr->need_walusage)
+		WalUsageAccumDiff(&instr->walusage,
+						  &pgWalUsage, &instr->walusage_start);
+
+	/* Is this the first tuple of this cycle? */
+	if (!is_running_true(node))
+	{
+		set_running_true(node);
+		if (instr->need_timer)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+	else
+	{
+		/*
+		 * In async mode, if the plan node hadn't emitted any tuples before,
+		 * this might be the first tuple
+		 */
+		if (instr->need_timer && instr->async_mode && save_tuplecount < 1)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+}
+
+static pg_attribute_always_inline void
+InstrStopNodeTrigger(ResultRelInfo *relInfo, Instrumentation *instr, uint64_t nTuples)
+{
+	uint64_t		save_tuplecount = get_tuplecount(relInfo);
+	instr_time	endtime;
+
+	/* count the returned tuples */
+	add_tuplecount(relInfo, nTuples);
+	instr->tuplecount = get_tuplecount(relInfo);;
+
+	/* let's update the time only if the timer was requested */
+	if (instr->need_timer)
+	{
+		if (INSTR_TIME_IS_ZERO(instr->starttime))
+			elog(ERROR, "InstrStopNode called without start");
+
+		INSTR_TIME_SET_CURRENT(endtime);
+		INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
+
+		INSTR_TIME_SET_ZERO(instr->starttime);
+	}
+
+	/* Add delta of buffer usage since entry to node's totals */
+	if (instr->need_bufusage)
+		BufferUsageAccumDiff(&instr->bufusage,
+							 &pgBufferUsage, &instr->bufusage_start);
+
+	if (instr->need_walusage)
+		WalUsageAccumDiff(&instr->walusage,
+						  &pgWalUsage, &instr->walusage_start);
+
+	/* Is this the first tuple of this cycle? */
+	if (!is_running_true(relInfo))
+	{
+		set_running_true(relInfo);
+		instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+	else
+	{
+		/*
+		 * In async mode, if the plan node hadn't emitted any tuples before,
+		 * this might be the first tuple
+		 */
+		if (instr->async_mode && save_tuplecount < 1)
+			instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
+	}
+}
+
+/* Update tuple count */
+static pg_attribute_always_inline void
+InstrUpdateTupleCount(PlanState *node, uint64_t nTuples)
+{
+	/* count the returned tuples */
+	add_tuplecount(node, nTuples);
+}
+
+
+/* Finish a run cycle for a plan node */
+static pg_attribute_always_inline void
+InstrEndLoop(PlanState *node)
+{
+	double		totaltime;
+	Instrumentation *instr = node->instrument;
+
+	/* Skip if nothing has happened, or already shut down */
+	if (!is_running_true(node))
+		return;
+
+	if (!INSTR_TIME_IS_ZERO(instr->starttime))
+		elog(ERROR, "InstrEndLoop called on running node");
+
+	/* Accumulate per-cycle statistics into totals */
+	if (instr->need_timer)
+	{
+		totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
+
+		instr->startup += instr->firsttuple;
+		instr->total += totaltime;
+	}
+	instr->ntuples += get_tuplecount(node);
+	instr->nloops += 1;
+
+	/* Reset for next cycle (if any) */
+	set_running_false(node);
+	if (instr->need_timer)
+	{
+		INSTR_TIME_SET_ZERO(instr->starttime);
+		INSTR_TIME_SET_ZERO(instr->counter);
+		instr->firsttuple = 0;
+	}
+	set_tuplecount(node, 0);
+}
+
+/* Finish a run cycle for a plan node */
+static pg_attribute_always_inline void
+InstrEndLoopResultRelInfo(ResultRelInfo *rInfo, Instrumentation *instr)
+{
+	double		totaltime;
+
+	/* Skip if nothing has happened, or already shut down */
+	if (!instr->running)
+		return;
+
+	if (!INSTR_TIME_IS_ZERO(instr->starttime))
+		elog(ERROR, "InstrEndLoop called on running node");
+
+	/* Accumulate per-cycle statistics into totals */
+	if (instr->need_timer)
+	{
+		totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
+
+		instr->startup += instr->firsttuple;
+		instr->total += totaltime;
+	}
+	instr->ntuples += get_tuplecount(rInfo);
+	instr->nloops += 1;
+
+	/* Reset for next cycle (if any) */
+	set_running_false(rInfo);
+	instr->running = false;
+	if (instr->need_timer)
+	{
+		INSTR_TIME_SET_ZERO(instr->starttime);
+		INSTR_TIME_SET_ZERO(instr->counter);
+		instr->firsttuple = 0;
+	}
+	set_tuplecount(rInfo, 0);
+	instr->tuplecount = 0;
+}
+
 #endif							/* EXECNODES_H */
