diff --git a/src/backend/executor/execExprInterp.c b/src/backend/executor/execExprInterp.c
index 1a37737d4a2..a85ae954044 100644
--- a/src/backend/executor/execExprInterp.c
+++ b/src/backend/executor/execExprInterp.c
@@ -79,6 +79,7 @@
 #include "utils/timestamp.h"
 #include "utils/typcache.h"
 #include "utils/xml.h"
+#include "miscadmin.h"
 
 /*
  * Use computed-goto-based opcode dispatch when computed gotos are available.
@@ -467,6 +468,7 @@ ExecInterpExpr(ExprState *state, ExprContext *econtext, bool *isnull)
 	TupleTableSlot *oldslot;
 	TupleTableSlot *newslot;
 
+	__atomic_fetch_add(&ExecInterpExpr_calls, 1, __ATOMIC_RELAXED);
 	/*
 	 * This array has to be in the same order as enum ExprEvalOp.
 	 */
diff --git a/src/backend/executor/execProcnode.c b/src/backend/executor/execProcnode.c
index f5f9cfbeead..189dcbdb3e1 100644
--- a/src/backend/executor/execProcnode.c
+++ b/src/backend/executor/execProcnode.c
@@ -479,6 +479,7 @@ static TupleTableSlot *
 ExecProcNodeInstr(PlanState *node)
 {
 	TupleTableSlot *result;
+	__atomic_fetch_add(&ExecProcNodeInstr_calls, 1, __ATOMIC_RELAXED);
 
 	InstrStartNode(node->instrument);
 
diff --git a/src/backend/executor/instrument.c b/src/backend/executor/instrument.c
index 56e635f4700..ec0a965dfa0 100644
--- a/src/backend/executor/instrument.c
+++ b/src/backend/executor/instrument.c
@@ -16,6 +16,7 @@
 #include <unistd.h>
 
 #include "executor/instrument.h"
+#include "miscadmin.h"
 
 BufferUsage pgBufferUsage;
 static BufferUsage save_pgBufferUsage;
@@ -67,6 +68,8 @@ InstrInit(Instrumentation *instr, int instrument_options)
 void
 InstrStartNode(Instrumentation *instr)
 {
+	__atomic_fetch_add(&InstrStartNode_calls, 1, __ATOMIC_RELAXED);
+
 	if (instr->need_timer &&
 		!INSTR_TIME_SET_CURRENT_LAZY(instr->starttime))
 		elog(ERROR, "InstrStartNode called twice in a row");
@@ -86,6 +89,8 @@ InstrStopNode(Instrumentation *instr, double nTuples)
 	double		save_tuplecount = instr->tuplecount;
 	instr_time	endtime;
 
+	__atomic_fetch_add(&InstrStopNode_calls, 1, __ATOMIC_RELAXED);
+
 	/* count the returned tuples */
 	instr->tuplecount += nTuples;
 
@@ -141,6 +146,8 @@ InstrEndLoop(Instrumentation *instr)
 {
 	double		totaltime;
 
+	__atomic_fetch_add(&InstrEndLoop_calls, 1, __ATOMIC_RELAXED);
+
 	/* Skip if nothing has happened, or already shut down */
 	if (!instr->running)
 		return;
diff --git a/src/backend/main/main.c b/src/backend/main/main.c
index bdcb5e4f261..632cfe80b16 100644
--- a/src/backend/main/main.c
+++ b/src/backend/main/main.c
@@ -63,7 +63,6 @@ static void init_locale(const char *categoryname, int category, const char *loca
 static void help(const char *progname);
 static void check_root(const char *progname);
 
-
 /*
  * Any Postgres server process begins execution here.
  */
diff --git a/src/backend/tcop/postgres.c b/src/backend/tcop/postgres.c
index a297606cdd7..4fffef5e8cf 100644
--- a/src/backend/tcop/postgres.c
+++ b/src/backend/tcop/postgres.c
@@ -186,6 +186,33 @@ static void log_disconnections(int code, Datum arg);
 static void enable_statement_timeout(void);
 static void disable_statement_timeout(void);
 
+/*
+ *
+ */
+static void print_function_counts(int sig);
+
+static void
+print_function_counts(int sig)
+{
+	long long start_count = __atomic_load_n(&InstrStartNode_calls, __ATOMIC_RELAXED);
+	long long stop_count = __atomic_load_n(&InstrStopNode_calls, __ATOMIC_RELAXED);
+	long long loop_count = __atomic_load_n(&InstrEndLoop_calls, __ATOMIC_RELAXED);
+	long long instr_count = __atomic_load_n(&ExecProcNodeInstr_calls, __ATOMIC_RELAXED);
+	long long expr_count = __atomic_load_n(&ExecInterpExpr_calls, __ATOMIC_RELAXED);
+
+	fprintf(stderr, "=====================\n");
+	fprintf(stderr, "ExecInterpExpr: %lld\n", expr_count);
+	fprintf(stderr, "ExecProcNodeInstr: %lld\n", instr_count);
+	fprintf(stderr, "InstrStartNode: %lld\n", start_count);
+	fprintf(stderr, "InstrStopNode: %lld\n", stop_count);
+	fprintf(stderr, "InstrEndLoop: %lld\n", loop_count);
+
+	__atomic_store_n(&InstrStartNode_calls, 0, __ATOMIC_RELAXED);
+	__atomic_store_n(&InstrStopNode_calls, 0, __ATOMIC_RELAXED);
+	__atomic_store_n(&InstrEndLoop_calls, 0, __ATOMIC_RELAXED);
+	__atomic_store_n(&ExecProcNodeInstr_calls, 0, __ATOMIC_RELAXED);
+	__atomic_store_n(&ExecInterpExpr_calls, 0, __ATOMIC_RELAXED);
+}
 
 /* ----------------------------------------------------------------
  *		infrastructure for valgrind debugging
@@ -4241,7 +4268,8 @@ PostgresMain(const char *dbname, const char *username)
 		 */
 		pqsignal(SIGPIPE, SIG_IGN);
 		pqsignal(SIGUSR1, procsignal_sigusr1_handler);
-		pqsignal(SIGUSR2, SIG_IGN);
+		//pqsignal(SIGUSR2, SIG_IGN);
+		pqsignal(SIGUSR2, print_function_counts);
 		pqsignal(SIGFPE, FloatExceptionHandler);
 
 		/*
diff --git a/src/backend/utils/init/globals.c b/src/backend/utils/init/globals.c
index d31cb45a058..15fe5396305 100644
--- a/src/backend/utils/init/globals.c
+++ b/src/backend/utils/init/globals.c
@@ -165,3 +165,13 @@ int			notify_buffers = 16;
 int			serializable_buffers = 32;
 int			subtransaction_buffers = 0;
 int			transaction_buffers = 0;
+
+/*
+ * function counter
+ */
+volatile long long InstrStartNode_calls = 0;
+volatile long long InstrStopNode_calls = 0;
+volatile long long InstrEndLoop_calls = 0;
+
+volatile long long ExecProcNodeInstr_calls = 0;
+volatile long long ExecInterpExpr_calls = 0;
diff --git a/src/include/miscadmin.h b/src/include/miscadmin.h
index 1bef98471c3..f4f872ca04c 100644
--- a/src/include/miscadmin.h
+++ b/src/include/miscadmin.h
@@ -539,4 +539,14 @@ extern void RestoreClientConnectionInfo(char *conninfo);
 /* in executor/nodeHash.c */
 extern size_t get_hash_memory_limit(void);
 
+
+/*
+ *
+ */
+extern volatile long long InstrStartNode_calls;
+extern volatile long long InstrStopNode_calls;
+extern volatile long long InstrEndLoop_calls;
+extern volatile long long ExecProcNodeInstr_calls;
+extern volatile long long ExecInterpExpr_calls;
+
 #endif							/* MISCADMIN_H */
